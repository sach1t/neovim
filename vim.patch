diff --git a/src/Makefile b/src/Makefile
index 5b510e0..e19b799 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -563,7 +563,7 @@ CClink = $(CC)
 # When using -g with some older versions of Linux you might get a
 # statically linked executable.
 # When not defined, configure will try to use -O2 -g for gcc and -O for cc.
-#CFLAGS = -g
+CFLAGS = -g
 #CFLAGS = -O
 
 # Optimization limits - depends on the compiler.  Automatic check in configure
diff --git a/src/term.c b/src/term.c
index 7ff5af6..1b9ac6e 100644
--- a/src/term.c
+++ b/src/term.c
@@ -89,7 +89,7 @@ static void check_for_codes_from_term(void);
 #endif
 #if defined(FEAT_GUI) \
     || (defined(FEAT_MOUSE) && (!defined(UNIX) || defined(FEAT_MOUSE_XTERM) \
-		|| defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)))
+                || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)))
 static int get_bytes_from_buf(char_u *, char_u *, int);
 #endif
 static void del_termcode_idx(int idx);
@@ -109,10 +109,10 @@ static char_u *tgetent_error(char_u *, char_u *);
 char		*tgetstr(char *, char **);
 
 # ifdef FEAT_TERMRESPONSE
-    /* Change this to "if 1" to debug what happens with termresponse. */
+/* Change this to "if 1" to debug what happens with termresponse. */
 #  if 0
 #   define DEBUG_TERMRESPONSE
-    static void log_tr(char *msg);
+static void log_tr(char *msg);
 #   define LOG_TR(msg) log_tr(msg)
 #  else
 #   define LOG_TR(msg)
@@ -167,9 +167,9 @@ static struct builtin_term builtin_termcaps[] =
 {
 
 #if defined(FEAT_GUI)
-/*
- * GUI pseudo term-cap.
- */
+    /*
+     * GUI pseudo term-cap.
+     */
     {(int)KS_NAME,	"gui"},
     {(int)KS_CE,	IF_EB("\033|$", ESC_STR "|$")},
     {(int)KS_AL,	IF_EB("\033|i", ESC_STR "|i")},
@@ -193,7 +193,7 @@ static struct builtin_term builtin_termcaps[] =
 #  endif
 # endif
     {(int)KS_CL,	IF_EB("\033|C", ESC_STR "|C")},
-			/* attributes switched on with 'h', off with * 'H' */
+    /* attributes switched on with 'h', off with * 'H' */
     {(int)KS_ME,	IF_EB("\033|31H", ESC_STR "|31H")}, /* HL_ALL */
     {(int)KS_MR,	IF_EB("\033|1h", ESC_STR "|1h")},   /* HL_INVERSE */
     {(int)KS_MD,	IF_EB("\033|2h", ESC_STR "|2h")},   /* HL_BOLD */
@@ -216,16 +216,16 @@ static struct builtin_term builtin_termcaps[] =
 # else
     {(int)KS_CM,	IF_EB("\033|%d;%dM", ESC_STR "|%d;%dM")},
 # endif
-	/* there are no key sequences here, the GUI sequences are recognized
-	 * in check_termcode() */
+    /* there are no key sequences here, the GUI sequences are recognized
+     * in check_termcode() */
 #endif
 
 #ifndef NO_BUILTIN_TCAPS
 
 # if defined(AMIGA) || defined(ALL_BUILTIN_TCAPS)
-/*
- * Amiga console window, default for Amiga
- */
+    /*
+     * Amiga console window, default for Amiga
+     */
     {(int)KS_NAME,	"amiga"},
     {(int)KS_CE,	"\033[K"},
     {(int)KS_CD,	"\033[J"},
@@ -323,9 +323,9 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(__BEOS__) || defined(ALL_BUILTIN_TCAPS)
-/*
- * almost standard ANSI terminal, default for bebox
- */
+    /*
+     * almost standard ANSI terminal, default for bebox
+     */
     {(int)KS_NAME,	"beos-ansi"},
     {(int)KS_CE,	"\033[K"},
     {(int)KS_CD,	"\033[J"},
@@ -396,9 +396,9 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS) || defined(__EMX__)
-/*
- * standard ANSI terminal, default for unix
- */
+    /*
+     * standard ANSI terminal, default for unix
+     */
     {(int)KS_NAME,	"ansi"},
     {(int)KS_CE,	IF_EB("\033[K", ESC_STR "[K")},
     {(int)KS_AL,	IF_EB("\033[L", ESC_STR "[L")},
@@ -432,12 +432,12 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(ALL_BUILTIN_TCAPS) || defined(__EMX__)
-/*
- * These codes are valid when nansi.sys or equivalent has been installed.
- * Function keys on a PC are preceded with a NUL. These are converted into
- * K_NUL '\316' in mch_inchar(), because we cannot handle NULs in key codes.
- * CTRL-arrow is used instead of SHIFT-arrow.
- */
+    /*
+     * These codes are valid when nansi.sys or equivalent has been installed.
+     * Function keys on a PC are preceded with a NUL. These are converted into
+     * K_NUL '\316' in mch_inchar(), because we cannot handle NULs in key codes.
+     * CTRL-arrow is used instead of SHIFT-arrow.
+     */
 #ifdef __EMX__
     {(int)KS_NAME,	"os2ansi"},
 #else
@@ -517,11 +517,11 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(WIN3264) || defined(ALL_BUILTIN_TCAPS) || defined(__EMX__)
-/*
- * These codes are valid for the Win32 Console .  The entries that start with
- * ESC | are translated into console calls in os_win32.c.  The function keys
- * are also translated in os_win32.c.
- */
+    /*
+     * These codes are valid for the Win32 Console .  The entries that start with
+     * ESC | are translated into console calls in os_win32.c.  The function keys
+     * are also translated in os_win32.c.
+     */
     {(int)KS_NAME,	"win32"},
     {(int)KS_CE,	"\033|K"},	/* clear to end of line */
     {(int)KS_AL,	"\033|L"},	/* add new blank line */
@@ -643,13 +643,13 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(VMS) || defined(ALL_BUILTIN_TCAPS)
-/*
- * VT320 is working as an ANSI terminal compatible DEC terminal.
- * (it covers VT1x0, VT2x0 and VT3x0 up to VT320 on VMS as well)
- * Note: K_F1...K_F5 are for internal use, should not be defined.
- * TODO:- rewrite ESC[ codes to CSI
- *      - keyboard languages (CSI ? 26 n)
- */
+    /*
+     * VT320 is working as an ANSI terminal compatible DEC terminal.
+     * (it covers VT1x0, VT2x0 and VT3x0 up to VT320 on VMS as well)
+     * Note: K_F1...K_F5 are for internal use, should not be defined.
+     * TODO:- rewrite ESC[ codes to CSI
+     *      - keyboard languages (CSI ? 26 n)
+     */
     {(int)KS_NAME,	"vt320"},
     {(int)KS_CE,	IF_EB("\033[K", ESC_STR "[K")},
     {(int)KS_AL,	IF_EB("\033[L", ESC_STR "[L")},
@@ -685,7 +685,7 @@ static struct builtin_term builtin_termcaps[] =
     {(int)KS_LE,	"\b"},
 #  ifdef TERMINFO
     {(int)KS_CM,	IF_EB("\033[%i%p1%d;%p2%dH",
-						  ESC_STR "[%i%p1%d;%p2%dH")},
+            ESC_STR "[%i%p1%d;%p2%dH")},
 #  else
     {(int)KS_CM,	IF_EB("\033[%i%d;%dH", ESC_STR "[%i%d;%dH")},
 #  endif
@@ -733,15 +733,15 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(ALL_BUILTIN_TCAPS) || defined(__MINT__)
-/*
- * Ordinary vt52
- */
+    /*
+     * Ordinary vt52
+     */
     {(int)KS_NAME,	"vt52"},
     {(int)KS_CE,	IF_EB("\033K", ESC_STR "K")},
     {(int)KS_CD,	IF_EB("\033J", ESC_STR "J")},
 #  ifdef TERMINFO
     {(int)KS_CM,	IF_EB("\033Y%p1%' '%+%c%p2%' '%+%c",
-			    ESC_STR "Y%p1%' '%+%c%p2%' '%+%c")},
+            ESC_STR "Y%p1%' '%+%c%p2%' '%+%c")},
 #  else
     {(int)KS_CM,	IF_EB("\033Y%+ %+ ", ESC_STR "Y%+ %+ ")},
 #  endif
@@ -810,7 +810,7 @@ static struct builtin_term builtin_termcaps[] =
 #  endif
 #  ifdef TERMINFO
     {(int)KS_CS,	IF_EB("\033[%i%p1%d;%p2%dr",
-						  ESC_STR "[%i%p1%d;%p2%dr")},
+            ESC_STR "[%i%p1%d;%p2%dr")},
 #  else
     {(int)KS_CS,	IF_EB("\033[%i%d;%dr", ESC_STR "[%i%d;%dr")},
 #  endif
@@ -826,7 +826,7 @@ static struct builtin_term builtin_termcaps[] =
     {(int)KS_LE,	"\b"},
 #  ifdef TERMINFO
     {(int)KS_CM,	IF_EB("\033[%i%p1%d;%p2%dH",
-						  ESC_STR "[%i%p1%d;%p2%dH")},
+            ESC_STR "[%i%p1%d;%p2%dH")},
 #  else
     {(int)KS_CM,	IF_EB("\033[%i%d;%dH", ESC_STR "[%i%d;%dH")},
 #  endif
@@ -841,7 +841,7 @@ static struct builtin_term builtin_termcaps[] =
 #  ifdef FEAT_XTERM_SAVE
     {(int)KS_TI,	IF_EB("\0337\033[?47h", ESC_STR "7" ESC_STR_nc "[?47h")},
     {(int)KS_TE,	IF_EB("\033[2J\033[?47l\0338",
-				  ESC_STR "[2J" ESC_STR_nc "[?47l" ESC_STR_nc "8")},
+            ESC_STR "[2J" ESC_STR_nc "[?47l" ESC_STR_nc "8")},
 #  endif
     {(int)KS_CIS,	IF_EB("\033]1;", ESC_STR "]1;")},
     {(int)KS_CIE,	"\007"},
@@ -849,9 +849,9 @@ static struct builtin_term builtin_termcaps[] =
     {(int)KS_FS,	"\007"},
 #  ifdef TERMINFO
     {(int)KS_CWS,	IF_EB("\033[8;%p1%d;%p2%dt",
-						  ESC_STR "[8;%p1%d;%p2%dt")},
+            ESC_STR "[8;%p1%d;%p2%dt")},
     {(int)KS_CWP,	IF_EB("\033[3;%p1%d;%p2%dt",
-						  ESC_STR "[3;%p1%d;%p2%dt")},
+            ESC_STR "[3;%p1%d;%p2%dt")},
 #  else
     {(int)KS_CWS,	IF_EB("\033[8;%d;%dt", ESC_STR "[8;%d;%dt")},
     {(int)KS_CWP,	IF_EB("\033[3;%d;%dt", ESC_STR "[3;%d;%dt")},
@@ -949,9 +949,9 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(UNIX) || defined(ALL_BUILTIN_TCAPS)
-/*
- * iris-ansi for Silicon Graphics machines.
- */
+    /*
+     * iris-ansi for Silicon Graphics machines.
+     */
     {(int)KS_NAME,	"iris-ansi"},
     {(int)KS_CE,	"\033[K"},
     {(int)KS_CD,	"\033[J"},
@@ -1065,9 +1065,9 @@ static struct builtin_term builtin_termcaps[] =
 # endif
 
 # if defined(DEBUG) || defined(ALL_BUILTIN_TCAPS)
-/*
- * for debugging
- */
+    /*
+     * for debugging
+     */
     {(int)KS_NAME,	"debug"},
     {(int)KS_CE,	"[CE]"},
     {(int)KS_CD,	"[CD]"},
@@ -1245,22 +1245,22 @@ static struct builtin_term builtin_termcaps[] =
 
 #endif /* NO_BUILTIN_TCAPS */
 
-/*
- * The most minimal terminal: only clear screen and cursor positioning
- * Always included.
- */
+    /*
+     * The most minimal terminal: only clear screen and cursor positioning
+     * Always included.
+     */
     {(int)KS_NAME,	"dumb"},
     {(int)KS_CL,	"\014"},
 #ifdef TERMINFO
     {(int)KS_CM,	IF_EB("\033[%i%p1%d;%p2%dH",
-						  ESC_STR "[%i%p1%d;%p2%dH")},
+            ESC_STR "[%i%p1%d;%p2%dH")},
 #else
     {(int)KS_CM,	IF_EB("\033[%i%d;%dH", ESC_STR "[%i%d;%dH")},
 #endif
 
-/*
- * end marker
- */
+    /*
+     * end marker
+     */
     {(int)KS_NAME,	NULL}
 
 };	/* end of builtin_termcaps */
@@ -1278,11 +1278,11 @@ termgui_get_color(char_u *name)
     guicolor_T	t;
 
     if (*name == NUL)
-	return INVALCOLOR;
+        return INVALCOLOR;
     t = termgui_mch_get_color(name);
 
     if (t == INVALCOLOR)
-	EMSG2(_("E254: Cannot allocate color %s"), name);
+        EMSG2(_("E254: Cannot allocate color %s"), name);
     return t;
 }
 
@@ -1350,24 +1350,24 @@ find_builtin_term(char_u *term)
     p = builtin_termcaps;
     while (p->bt_string != NULL)
     {
-	if (p->bt_entry == (int)KS_NAME)
-	{
+        if (p->bt_entry == (int)KS_NAME)
+        {
 #ifdef UNIX
-	    if (STRCMP(p->bt_string, "iris-ansi") == 0 && vim_is_iris(term))
-		return p;
-	    else if (STRCMP(p->bt_string, "xterm") == 0 && vim_is_xterm(term))
-		return p;
-	    else
+            if (STRCMP(p->bt_string, "iris-ansi") == 0 && vim_is_iris(term))
+                return p;
+            else if (STRCMP(p->bt_string, "xterm") == 0 && vim_is_xterm(term))
+                return p;
+            else
 #endif
 #ifdef VMS
-		if (STRCMP(p->bt_string, "vt320") == 0 && vim_is_vt300(term))
-		    return p;
-		else
-#endif
-		  if (STRCMP(term, p->bt_string) == 0)
-		    return p;
-	}
-	++p;
+                if (STRCMP(p->bt_string, "vt320") == 0 && vim_is_vt300(term))
+                    return p;
+                else
+#endif
+                    if (STRCMP(term, p->bt_string) == 0)
+                        return p;
+        }
+        ++p;
     }
     return p;
 }
@@ -1389,45 +1389,45 @@ parse_builtin_tcap(char_u *term)
 
     /* Do not parse if builtin term not found */
     if (p->bt_string == NULL)
-	return;
+        return;
 
     for (++p; p->bt_entry != (int)KS_NAME && p->bt_entry != BT_EXTRA_KEYS; ++p)
     {
-	if ((int)p->bt_entry >= 0)	/* KS_xx entry */
-	{
-	    /* Only set the value if it wasn't set yet. */
-	    if (term_strings[p->bt_entry] == NULL
-				 || term_strings[p->bt_entry] == empty_option)
-	    {
-		/* 8bit terminal: use CSI instead of <Esc>[ */
-		if (term_8bit && term_7to8bit((char_u *)p->bt_string) != 0)
-		{
-		    char_u  *s, *t;
-
-		    s = vim_strsave((char_u *)p->bt_string);
-		    if (s != NULL)
-		    {
-			for (t = s; *t; ++t)
-			    if (term_7to8bit(t))
-			    {
-				*t = term_7to8bit(t);
-				STRCPY(t + 1, t + 2);
-			    }
-			term_strings[p->bt_entry] = s;
-			set_term_option_alloced(&term_strings[p->bt_entry]);
-		    }
-		}
-		else
-		    term_strings[p->bt_entry] = (char_u *)p->bt_string;
-	    }
-	}
-	else
-	{
-	    name[0] = KEY2TERMCAP0((int)p->bt_entry);
-	    name[1] = KEY2TERMCAP1((int)p->bt_entry);
-	    if (find_termcode(name) == NULL)
-		add_termcode(name, (char_u *)p->bt_string, term_8bit);
-	}
+        if ((int)p->bt_entry >= 0)	/* KS_xx entry */
+        {
+            /* Only set the value if it wasn't set yet. */
+            if (term_strings[p->bt_entry] == NULL
+                    || term_strings[p->bt_entry] == empty_option)
+            {
+                /* 8bit terminal: use CSI instead of <Esc>[ */
+                if (term_8bit && term_7to8bit((char_u *)p->bt_string) != 0)
+                {
+                    char_u  *s, *t;
+
+                    s = vim_strsave((char_u *)p->bt_string);
+                    if (s != NULL)
+                    {
+                        for (t = s; *t; ++t)
+                            if (term_7to8bit(t))
+                            {
+                                *t = term_7to8bit(t);
+                                STRCPY(t + 1, t + 2);
+                            }
+                        term_strings[p->bt_entry] = s;
+                        set_term_option_alloced(&term_strings[p->bt_entry]);
+                    }
+                }
+                else
+                    term_strings[p->bt_entry] = (char_u *)p->bt_string;
+            }
+        }
+        else
+        {
+            name[0] = KEY2TERMCAP0((int)p->bt_entry);
+            name[1] = KEY2TERMCAP1((int)p->bt_entry);
+            if (find_termcode(name) == NULL)
+                add_termcode(name, (char_u *)p->bt_string, term_8bit);
+        }
     }
 }
 #if defined(HAVE_TGETENT) || defined(FEAT_TERMRESPONSE)
@@ -1445,9 +1445,9 @@ set_color_count(int nr)
 
     t_colors = nr;
     if (t_colors > 1)
-	sprintf((char *)nr_colors, "%d", t_colors);
+        sprintf((char *)nr_colors, "%d", t_colors);
     else
-	*nr_colors = NUL;
+        *nr_colors = NUL;
     set_string_option_direct((char_u *)"t_Co", -1, nr_colors, OPT_FREE, 0);
 }
 #endif
@@ -1490,303 +1490,303 @@ set_termname(char_u *term)
 
     /* In silect mode (ex -s) we don't use the 'term' option. */
     if (silent_mode)
-	return OK;
+        return OK;
 
     detected_8bit = FALSE;		/* reset 8-bit detection */
 
     if (term_is_builtin(term))
     {
-	term += 8;
+        term += 8;
 #ifdef HAVE_TGETENT
-	builtin_first = 1;
+        builtin_first = 1;
 #endif
     }
 
-/*
- * If HAVE_TGETENT is not defined, only the builtin termcap is used, otherwise:
- *   If builtin_first is TRUE:
- *     0. try builtin termcap
- *     1. try external termcap
- *     2. if both fail default to a builtin terminal
- *   If builtin_first is FALSE:
- *     1. try external termcap
- *     2. try builtin termcap, if both fail default to a builtin terminal
- */
+    /*
+     * If HAVE_TGETENT is not defined, only the builtin termcap is used, otherwise:
+     *   If builtin_first is TRUE:
+     *     0. try builtin termcap
+     *     1. try external termcap
+     *     2. if both fail default to a builtin terminal
+     *   If builtin_first is FALSE:
+     *     1. try external termcap
+     *     2. try builtin termcap, if both fail default to a builtin terminal
+     */
 #ifdef HAVE_TGETENT
     for (try = builtin_first ? 0 : 1; try < 3; ++try)
     {
-	/*
-	 * Use external termcap
-	 */
-	if (try == 1)
-	{
-	    char_u	    *p;
-	    static char_u   tstrbuf[TBUFSZ];
-	    int		    i;
-	    char_u	    tbuf[TBUFSZ];
-	    char_u	    *tp;
-	    static struct {
-			    enum SpecialKey dest; /* index in term_strings[] */
-			    char *name;		  /* termcap name for string */
-			  } string_names[] =
-			    {	{KS_CE, "ce"}, {KS_AL, "al"}, {KS_CAL,"AL"},
-				{KS_DL, "dl"}, {KS_CDL,"DL"}, {KS_CS, "cs"},
-				{KS_CL, "cl"}, {KS_CD, "cd"},
-				{KS_VI, "vi"}, {KS_VE, "ve"}, {KS_MB, "mb"},
-				{KS_VS, "vs"}, {KS_ME, "me"}, {KS_MR, "mr"},
-				{KS_MD, "md"}, {KS_SE, "se"}, {KS_SO, "so"},
-				{KS_CZH,"ZH"}, {KS_CZR,"ZR"}, {KS_UE, "ue"},
-				{KS_US, "us"}, {KS_UCE, "Ce"}, {KS_UCS, "Cs"},
-				{KS_CM, "cm"}, {KS_SR, "sr"},
-				{KS_CRI,"RI"}, {KS_VB, "vb"}, {KS_KS, "ks"},
-				{KS_KE, "ke"}, {KS_TI, "ti"}, {KS_TE, "te"},
-				{KS_BC, "bc"}, {KS_CSB,"Sb"}, {KS_CSF,"Sf"},
-				{KS_CAB,"AB"}, {KS_CAF,"AF"}, {KS_LE, "le"},
-				{KS_ND, "nd"}, {KS_OP, "op"}, {KS_CRV, "RV"},
-				{KS_CIS, "IS"}, {KS_CIE, "IE"},
-				{KS_TS, "ts"}, {KS_FS, "fs"},
-				{KS_CWP, "WP"}, {KS_CWS, "WS"},
-				{KS_CSI, "SI"}, {KS_CEI, "EI"},
-				{KS_U7, "u7"}, {KS_RBG, "RB"},
-				{KS_8F, "8f"}, {KS_8B, "8b"},
-				{(enum SpecialKey)0, NULL}
-			    };
-
-	    /*
-	     * If the external termcap does not have a matching entry, try the
-	     * builtin ones.
-	     */
-	    if ((error_msg = tgetent_error(tbuf, term)) == NULL)
-	    {
-		tp = tstrbuf;
-		if (!termcap_cleared)
-		{
-		    clear_termoptions();	/* clear old options */
-		    termcap_cleared = TRUE;
-		}
-
-	    /* get output strings */
-		for (i = 0; string_names[i].name != NULL; ++i)
-		{
-		    if (term_str(string_names[i].dest) == NULL
-			    || term_str(string_names[i].dest) == empty_option)
-			term_str(string_names[i].dest) =
-					   TGETSTR(string_names[i].name, &tp);
-		}
-
-		/* tgetflag() returns 1 if the flag is present, 0 if not and
-		 * possibly -1 if the flag doesn't exist. */
-		if ((T_MS == NULL || T_MS == empty_option)
-							&& tgetflag("ms") > 0)
-		    T_MS = (char_u *)"y";
-		if ((T_XS == NULL || T_XS == empty_option)
-							&& tgetflag("xs") > 0)
-		    T_XS = (char_u *)"y";
-		if ((T_XN == NULL || T_XN == empty_option)
-							&& tgetflag("xn") > 0)
-		    T_XN = (char_u *)"y";
-		if ((T_DB == NULL || T_DB == empty_option)
-							&& tgetflag("db") > 0)
-		    T_DB = (char_u *)"y";
-		if ((T_DA == NULL || T_DA == empty_option)
-							&& tgetflag("da") > 0)
-		    T_DA = (char_u *)"y";
-		if ((T_UT == NULL || T_UT == empty_option)
-							&& tgetflag("ut") > 0)
-		    T_UT = (char_u *)"y";
-
-
-		/*
-		 * get key codes
-		 */
-		for (i = 0; key_names[i] != NULL; ++i)
-		{
-		    if (find_termcode((char_u *)key_names[i]) == NULL)
-		    {
-			p = TGETSTR(key_names[i], &tp);
-			/* if cursor-left == backspace, ignore it (televideo
-			 * 925) */
-			if (p != NULL
-				&& (*p != Ctrl_H
-				    || key_names[i][0] != 'k'
-				    || key_names[i][1] != 'l'))
-			    add_termcode((char_u *)key_names[i], p, FALSE);
-		    }
-		}
-
-		if (height == 0)
-		    height = tgetnum("li");
-		if (width == 0)
-		    width = tgetnum("co");
-
-		/*
-		 * Get number of colors (if not done already).
-		 */
-		if (term_str(KS_CCO) == NULL
-			|| term_str(KS_CCO) == empty_option)
-		    set_color_count(tgetnum("Co"));
+        /*
+         * Use external termcap
+         */
+        if (try == 1)
+        {
+            char_u	    *p;
+            static char_u   tstrbuf[TBUFSZ];
+            int		    i;
+            char_u	    tbuf[TBUFSZ];
+            char_u	    *tp;
+            static struct {
+                enum SpecialKey dest; /* index in term_strings[] */
+                char *name;		  /* termcap name for string */
+            } string_names[] =
+            {	{KS_CE, "ce"}, {KS_AL, "al"}, {KS_CAL,"AL"},
+                {KS_DL, "dl"}, {KS_CDL,"DL"}, {KS_CS, "cs"},
+                {KS_CL, "cl"}, {KS_CD, "cd"},
+                {KS_VI, "vi"}, {KS_VE, "ve"}, {KS_MB, "mb"},
+                {KS_VS, "vs"}, {KS_ME, "me"}, {KS_MR, "mr"},
+                {KS_MD, "md"}, {KS_SE, "se"}, {KS_SO, "so"},
+                {KS_CZH,"ZH"}, {KS_CZR,"ZR"}, {KS_UE, "ue"},
+                {KS_US, "us"}, {KS_UCE, "Ce"}, {KS_UCS, "Cs"},
+                {KS_CM, "cm"}, {KS_SR, "sr"},
+                {KS_CRI,"RI"}, {KS_VB, "vb"}, {KS_KS, "ks"},
+                {KS_KE, "ke"}, {KS_TI, "ti"}, {KS_TE, "te"},
+                {KS_BC, "bc"}, {KS_CSB,"Sb"}, {KS_CSF,"Sf"},
+                {KS_CAB,"AB"}, {KS_CAF,"AF"}, {KS_LE, "le"},
+                {KS_ND, "nd"}, {KS_OP, "op"}, {KS_CRV, "RV"},
+                {KS_CIS, "IS"}, {KS_CIE, "IE"},
+                {KS_TS, "ts"}, {KS_FS, "fs"},
+                {KS_CWP, "WP"}, {KS_CWS, "WS"},
+                {KS_CSI, "SI"}, {KS_CEI, "EI"},
+                {KS_U7, "u7"}, {KS_RBG, "RB"},
+                {KS_8F, "8f"}, {KS_8B, "8b"},
+                {(enum SpecialKey)0, NULL}
+            };
+
+            /*
+             * If the external termcap does not have a matching entry, try the
+             * builtin ones.
+             */
+            if ((error_msg = tgetent_error(tbuf, term)) == NULL)
+            {
+                tp = tstrbuf;
+                if (!termcap_cleared)
+                {
+                    clear_termoptions();	/* clear old options */
+                    termcap_cleared = TRUE;
+                }
+
+                /* get output strings */
+                for (i = 0; string_names[i].name != NULL; ++i)
+                {
+                    if (term_str(string_names[i].dest) == NULL
+                            || term_str(string_names[i].dest) == empty_option)
+                        term_str(string_names[i].dest) =
+                            TGETSTR(string_names[i].name, &tp);
+                }
+
+                /* tgetflag() returns 1 if the flag is present, 0 if not and
+                 * possibly -1 if the flag doesn't exist. */
+                if ((T_MS == NULL || T_MS == empty_option)
+                        && tgetflag("ms") > 0)
+                    T_MS = (char_u *)"y";
+                if ((T_XS == NULL || T_XS == empty_option)
+                        && tgetflag("xs") > 0)
+                    T_XS = (char_u *)"y";
+                if ((T_XN == NULL || T_XN == empty_option)
+                        && tgetflag("xn") > 0)
+                    T_XN = (char_u *)"y";
+                if ((T_DB == NULL || T_DB == empty_option)
+                        && tgetflag("db") > 0)
+                    T_DB = (char_u *)"y";
+                if ((T_DA == NULL || T_DA == empty_option)
+                        && tgetflag("da") > 0)
+                    T_DA = (char_u *)"y";
+                if ((T_UT == NULL || T_UT == empty_option)
+                        && tgetflag("ut") > 0)
+                    T_UT = (char_u *)"y";
+
+
+                /*
+                 * get key codes
+                 */
+                for (i = 0; key_names[i] != NULL; ++i)
+                {
+                    if (find_termcode((char_u *)key_names[i]) == NULL)
+                    {
+                        p = TGETSTR(key_names[i], &tp);
+                        /* if cursor-left == backspace, ignore it (televideo
+                         * 925) */
+                        if (p != NULL
+                                && (*p != Ctrl_H
+                                    || key_names[i][0] != 'k'
+                                    || key_names[i][1] != 'l'))
+                            add_termcode((char_u *)key_names[i], p, FALSE);
+                    }
+                }
+
+                if (height == 0)
+                    height = tgetnum("li");
+                if (width == 0)
+                    width = tgetnum("co");
+
+                /*
+                 * Get number of colors (if not done already).
+                 */
+                if (term_str(KS_CCO) == NULL
+                        || term_str(KS_CCO) == empty_option)
+                    set_color_count(tgetnum("Co"));
 
 # ifndef hpux
-		BC = (char *)TGETSTR("bc", &tp);
-		UP = (char *)TGETSTR("up", &tp);
-		p = TGETSTR("pc", &tp);
-		if (p)
-		    PC = *p;
+                BC = (char *)TGETSTR("bc", &tp);
+                UP = (char *)TGETSTR("up", &tp);
+                p = TGETSTR("pc", &tp);
+                if (p)
+                    PC = *p;
 # endif /* hpux */
-	    }
-	}
-	else	    /* try == 0 || try == 2 */
+            }
+        }
+        else	    /* try == 0 || try == 2 */
 #endif /* HAVE_TGETENT */
-	/*
-	 * Use builtin termcap
-	 */
-	{
+            /*
+             * Use builtin termcap
+             */
+        {
 #ifdef HAVE_TGETENT
-	    /*
-	     * If builtin termcap was already used, there is no need to search
-	     * for the builtin termcap again, quit now.
-	     */
-	    if (try == 2 && builtin_first && termcap_cleared)
-		break;
-#endif
-	    /*
-	     * search for 'term' in builtin_termcaps[]
-	     */
-	    termp = find_builtin_term(term);
-	    if (termp->bt_string == NULL)	/* did not find it */
-	    {
+            /*
+             * If builtin termcap was already used, there is no need to search
+             * for the builtin termcap again, quit now.
+             */
+            if (try == 2 && builtin_first && termcap_cleared)
+                break;
+#endif
+            /*
+             * search for 'term' in builtin_termcaps[]
+             */
+            termp = find_builtin_term(term);
+            if (termp->bt_string == NULL)	/* did not find it */
+            {
 #ifdef HAVE_TGETENT
-		/*
-		 * If try == 0, first try the external termcap. If that is not
-		 * found we'll get back here with try == 2.
-		 * If termcap_cleared is set we used the external termcap,
-		 * don't complain about not finding the term in the builtin
-		 * termcap.
-		 */
-		if (try == 0)			/* try external one */
-		    continue;
-		if (termcap_cleared)		/* found in external termcap */
-		    break;
-#endif
-
-		mch_errmsg("\r\n");
-		if (error_msg != NULL)
-		{
-		    mch_errmsg((char *)error_msg);
-		    mch_errmsg("\r\n");
-		}
-		mch_errmsg("'");
-		mch_errmsg((char *)term);
-		mch_errmsg(_("' not known. Available builtin terminals are:"));
-		mch_errmsg("\r\n");
-		for (termp = &(builtin_termcaps[0]); termp->bt_string != NULL;
-								      ++termp)
-		{
-		    if (termp->bt_entry == (int)KS_NAME)
-		    {
+                /*
+                 * If try == 0, first try the external termcap. If that is not
+                 * found we'll get back here with try == 2.
+                 * If termcap_cleared is set we used the external termcap,
+                 * don't complain about not finding the term in the builtin
+                 * termcap.
+                 */
+                if (try == 0)			/* try external one */
+                    continue;
+                if (termcap_cleared)		/* found in external termcap */
+                    break;
+#endif
+
+                mch_errmsg("\r\n");
+                if (error_msg != NULL)
+                {
+                    mch_errmsg((char *)error_msg);
+                    mch_errmsg("\r\n");
+                }
+                mch_errmsg("'");
+                mch_errmsg((char *)term);
+                mch_errmsg(_("' not known. Available builtin terminals are:"));
+                mch_errmsg("\r\n");
+                for (termp = &(builtin_termcaps[0]); termp->bt_string != NULL;
+                        ++termp)
+                {
+                    if (termp->bt_entry == (int)KS_NAME)
+                    {
 #ifdef HAVE_TGETENT
-			mch_errmsg("    builtin_");
+                        mch_errmsg("    builtin_");
 #else
-			mch_errmsg("    ");
-#endif
-			mch_errmsg(termp->bt_string);
-			mch_errmsg("\r\n");
-		    }
-		}
-		/* when user typed :set term=xxx, quit here */
-		if (starting != NO_SCREEN)
-		{
-		    screen_start();	/* don't know where cursor is now */
-		    wait_return(TRUE);
-		    return FAIL;
-		}
-		term = DEFAULT_TERM;
-		mch_errmsg(_("defaulting to '"));
-		mch_errmsg((char *)term);
-		mch_errmsg("'\r\n");
-		if (emsg_silent == 0)
-		{
-		    screen_start();	/* don't know where cursor is now */
-		    out_flush();
-		    ui_delay(2000L, TRUE);
-		}
-		set_string_option_direct((char_u *)"term", -1, term,
-								 OPT_FREE, 0);
-		display_errors();
-	    }
-	    out_flush();
+                        mch_errmsg("    ");
+#endif
+                        mch_errmsg(termp->bt_string);
+                        mch_errmsg("\r\n");
+                    }
+                }
+                /* when user typed :set term=xxx, quit here */
+                if (starting != NO_SCREEN)
+                {
+                    screen_start();	/* don't know where cursor is now */
+                    wait_return(TRUE);
+                    return FAIL;
+                }
+                term = DEFAULT_TERM;
+                mch_errmsg(_("defaulting to '"));
+                mch_errmsg((char *)term);
+                mch_errmsg("'\r\n");
+                if (emsg_silent == 0)
+                {
+                    screen_start();	/* don't know where cursor is now */
+                    out_flush();
+                    ui_delay(2000L, TRUE);
+                }
+                set_string_option_direct((char_u *)"term", -1, term,
+                        OPT_FREE, 0);
+                display_errors();
+            }
+            out_flush();
 #ifdef HAVE_TGETENT
-	    if (!termcap_cleared)
-	    {
+            if (!termcap_cleared)
+            {
 #endif
-		clear_termoptions();	    /* clear old options */
+                clear_termoptions();	    /* clear old options */
 #ifdef HAVE_TGETENT
-		termcap_cleared = TRUE;
-	    }
+                termcap_cleared = TRUE;
+            }
 #endif
-	    parse_builtin_tcap(term);
+            parse_builtin_tcap(term);
 #ifdef FEAT_GUI
-	    if (term_is_gui(term))
-	    {
-		out_flush();
-		gui_init();
-		/* If starting the GUI failed, don't do any of the other
-		 * things for this terminal */
-		if (!gui.in_use)
-		    return FAIL;
+            if (term_is_gui(term))
+            {
+                out_flush();
+                gui_init();
+                /* If starting the GUI failed, don't do any of the other
+                 * things for this terminal */
+                if (!gui.in_use)
+                    return FAIL;
 #ifdef HAVE_TGETENT
-		break;		/* don't try using external termcap */
+                break;		/* don't try using external termcap */
 #endif
-	    }
+            }
 #endif /* FEAT_GUI */
-	}
+        }
 #ifdef HAVE_TGETENT
     }
 #endif
 
-/*
- * special: There is no info in the termcap about whether the cursor
- * positioning is relative to the start of the screen or to the start of the
- * scrolling region.  We just guess here. Only msdos pcterm is known to do it
- * relative.
- */
+    /*
+     * special: There is no info in the termcap about whether the cursor
+     * positioning is relative to the start of the screen or to the start of the
+     * scrolling region.  We just guess here. Only msdos pcterm is known to do it
+     * relative.
+     */
     if (STRCMP(term, "pcterm") == 0)
-	T_CCS = (char_u *)"yes";
+        T_CCS = (char_u *)"yes";
     else
-	T_CCS = empty_option;
+        T_CCS = empty_option;
 
 #ifdef UNIX
-/*
- * Any "stty" settings override the default for t_kb from the termcap.
- * This is in os_unix.c, because it depends a lot on the version of unix that
- * is being used.
- * Don't do this when the GUI is active, it uses "t_kb" and "t_kD" directly.
- */
+    /*
+     * Any "stty" settings override the default for t_kb from the termcap.
+     * This is in os_unix.c, because it depends a lot on the version of unix that
+     * is being used.
+     * Don't do this when the GUI is active, it uses "t_kb" and "t_kD" directly.
+     */
 #ifdef FEAT_GUI
     if (!gui.in_use)
 #endif
-	get_stty();
+        get_stty();
 #endif
 
-/*
- * If the termcap has no entry for 'bs' and/or 'del' and the ioctl() also
- * didn't work, use the default CTRL-H
- * The default for t_kD is DEL, unless t_kb is DEL.
- * The vim_strsave'd strings are probably lost forever, well it's only two
- * bytes.  Don't do this when the GUI is active, it uses "t_kb" and "t_kD"
- * directly.
- */
+    /*
+     * If the termcap has no entry for 'bs' and/or 'del' and the ioctl() also
+     * didn't work, use the default CTRL-H
+     * The default for t_kD is DEL, unless t_kb is DEL.
+     * The vim_strsave'd strings are probably lost forever, well it's only two
+     * bytes.  Don't do this when the GUI is active, it uses "t_kb" and "t_kD"
+     * directly.
+     */
 #ifdef FEAT_GUI
     if (!gui.in_use)
 #endif
     {
-	bs_p = find_termcode((char_u *)"kb");
-	del_p = find_termcode((char_u *)"kD");
-	if (bs_p == NULL || *bs_p == NUL)
-	    add_termcode((char_u *)"kb", (bs_p = (char_u *)CTRL_H_STR), FALSE);
-	if ((del_p == NULL || *del_p == NUL) &&
-					    (bs_p == NULL || *bs_p != DEL))
-	    add_termcode((char_u *)"kD", (char_u *)DEL_STR, FALSE);
+        bs_p = find_termcode((char_u *)"kb");
+        del_p = find_termcode((char_u *)"kD");
+        if (bs_p == NULL || *bs_p == NUL)
+            add_termcode((char_u *)"kb", (bs_p = (char_u *)CTRL_H_STR), FALSE);
+        if ((del_p == NULL || *del_p == NUL) &&
+                (bs_p == NULL || *bs_p != DEL))
+            add_termcode((char_u *)"kD", (char_u *)DEL_STR, FALSE);
     }
 
 #if defined(UNIX) || defined(VMS)
@@ -1801,31 +1801,31 @@ set_termname(char_u *term)
      * The termcode for the mouse is added as a side effect in option.c.
      */
     {
-	char_u	*p;
+        char_u	*p;
 
-	p = (char_u *)"";
+        p = (char_u *)"";
 #  ifdef FEAT_MOUSE_XTERM
-	if (use_xterm_like_mouse(term))
-	{
-	    if (use_xterm_mouse())
-		p = NULL;	/* keep existing value, might be "xterm2" */
-	    else
-		p = (char_u *)"xterm";
-	}
+        if (use_xterm_like_mouse(term))
+        {
+            if (use_xterm_mouse())
+                p = NULL;	/* keep existing value, might be "xterm2" */
+            else
+                p = (char_u *)"xterm";
+        }
 #  endif
-	if (p != NULL)
-	{
-	    set_option_value((char_u *)"ttym", 0L, p, 0);
-	    /* Reset the WAS_SET flag, 'ttymouse' can be set to "sgr" or
-	     * "xterm2" in check_termcode(). */
-	    reset_option_was_set((char_u *)"ttym");
-	}
-	if (p == NULL
+        if (p != NULL)
+        {
+            set_option_value((char_u *)"ttym", 0L, p, 0);
+            /* Reset the WAS_SET flag, 'ttymouse' can be set to "sgr" or
+             * "xterm2" in check_termcode(). */
+            reset_option_was_set((char_u *)"ttym");
+        }
+        if (p == NULL
 #   ifdef FEAT_GUI
-		|| gui.in_use
+                || gui.in_use
 #   endif
-		)
-	    check_mouse_termcode();	/* set mouse termcode anyway */
+           )
+            check_mouse_termcode();	/* set mouse termcode anyway */
     }
 #  endif
 # else
@@ -1836,12 +1836,12 @@ set_termname(char_u *term)
 #ifdef USE_TERM_CONSOLE
     /* DEFAULT_TERM indicates that it is the machine console. */
     if (STRCMP(term, DEFAULT_TERM) != 0)
-	term_console = FALSE;
+        term_console = FALSE;
     else
     {
-	term_console = TRUE;
+        term_console = TRUE;
 # ifdef AMIGA
-	win_resize_on();	/* enable window resizing reports */
+        win_resize_on();	/* enable window resizing reports */
 # endif
     }
 #endif
@@ -1851,14 +1851,14 @@ set_termname(char_u *term)
      * 'ttyfast' is default on for xterm, iris-ansi and a few others.
      */
     if (vim_is_fastterm(term))
-	p_tf = TRUE;
+        p_tf = TRUE;
 #endif
 #ifdef USE_TERM_CONSOLE
     /*
      * 'ttyfast' is default on consoles
      */
     if (term_console)
-	p_tf = TRUE;
+        p_tf = TRUE;
 #endif
 
     ttest(TRUE);	/* make sure we have a valid set of terminal codes */
@@ -1878,52 +1878,52 @@ set_termname(char_u *term)
      */
     if (starting != NO_SCREEN)
     {
-	starttermcap();		/* may change terminal mode */
+        starttermcap();		/* may change terminal mode */
 #ifdef FEAT_MOUSE
-	setmouse();		/* may start using the mouse */
+        setmouse();		/* may start using the mouse */
 #endif
 #ifdef FEAT_TITLE
-	maketitle();		/* may display window title */
+        maketitle();		/* may display window title */
 #endif
     }
 
-	/* display initial screen after ttest() checking. jw. */
+    /* display initial screen after ttest() checking. jw. */
     if (width <= 0 || height <= 0)
     {
-	/* termcap failed to report size */
-	/* set defaults, in case ui_get_shellsize() also fails */
-	width = 80;
+        /* termcap failed to report size */
+        /* set defaults, in case ui_get_shellsize() also fails */
+        width = 80;
 #if defined(WIN3264)
-	height = 25;	    /* console is often 25 lines */
+        height = 25;	    /* console is often 25 lines */
 #else
-	height = 24;	    /* most terminals are 24 lines */
+        height = 24;	    /* most terminals are 24 lines */
 #endif
     }
     set_shellsize(width, height, FALSE);	/* may change Rows */
     if (starting != NO_SCREEN)
     {
-	if (scroll_region)
-	    scroll_region_reset();		/* In case Rows changed */
-	check_map_keycodes();	/* check mappings for terminal codes used */
+        if (scroll_region)
+            scroll_region_reset();		/* In case Rows changed */
+        check_map_keycodes();	/* check mappings for terminal codes used */
 
 #ifdef FEAT_AUTOCMD
-	{
-	    buf_T	*old_curbuf;
-
-	    /*
-	     * Execute the TermChanged autocommands for each buffer that is
-	     * loaded.
-	     */
-	    old_curbuf = curbuf;
-	    for (curbuf = firstbuf; curbuf != NULL; curbuf = curbuf->b_next)
-	    {
-		if (curbuf->b_ml.ml_mfp != NULL)
-		    apply_autocmds(EVENT_TERMCHANGED, NULL, NULL, FALSE,
-								      curbuf);
-	    }
-	    if (buf_valid(old_curbuf))
-		curbuf = old_curbuf;
-	}
+        {
+            buf_T	*old_curbuf;
+
+            /*
+             * Execute the TermChanged autocommands for each buffer that is
+             * loaded.
+             */
+            old_curbuf = curbuf;
+            for (curbuf = firstbuf; curbuf != NULL; curbuf = curbuf->b_next)
+            {
+                if (curbuf->b_ml.ml_mfp != NULL)
+                    apply_autocmds(EVENT_TERMCHANGED, NULL, NULL, FALSE,
+                            curbuf);
+            }
+            if (buf_valid(old_curbuf))
+                curbuf = old_curbuf;
+        }
 #endif
     }
 
@@ -1948,10 +1948,10 @@ static int has_mouse_termcode = 0;
 # endif
 
 # if (!defined(UNIX) || defined(FEAT_MOUSE_TTY)) || defined(PROTO)
-    void
+void
 set_mouse_termcode(
-    int		n,	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
-    char_u	*s)
+        int		n,	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
+        char_u	*s)
 {
     char_u	name[2];
 
@@ -1961,44 +1961,44 @@ set_mouse_termcode(
 #  ifdef FEAT_MOUSE_TTY
 #   ifdef FEAT_MOUSE_JSB
     if (n == KS_JSBTERM_MOUSE)
-	has_mouse_termcode |= HMT_JSBTERM;
+        has_mouse_termcode |= HMT_JSBTERM;
     else
 #   endif
 #   ifdef FEAT_MOUSE_NET
-    if (n == KS_NETTERM_MOUSE)
-	has_mouse_termcode |= HMT_NETTERM;
-    else
+        if (n == KS_NETTERM_MOUSE)
+            has_mouse_termcode |= HMT_NETTERM;
+        else
 #   endif
 #   ifdef FEAT_MOUSE_DEC
-    if (n == KS_DEC_MOUSE)
-	has_mouse_termcode |= HMT_DEC;
-    else
+            if (n == KS_DEC_MOUSE)
+                has_mouse_termcode |= HMT_DEC;
+            else
 #   endif
 #   ifdef FEAT_MOUSE_PTERM
-    if (n == KS_PTERM_MOUSE)
-	has_mouse_termcode |= HMT_PTERM;
-    else
+                if (n == KS_PTERM_MOUSE)
+                    has_mouse_termcode |= HMT_PTERM;
+                else
 #   endif
 #   ifdef FEAT_MOUSE_URXVT
-    if (n == KS_URXVT_MOUSE)
-	has_mouse_termcode |= HMT_URXVT;
-    else
+                    if (n == KS_URXVT_MOUSE)
+                        has_mouse_termcode |= HMT_URXVT;
+                    else
 #   endif
 #   ifdef FEAT_MOUSE_SGR
-    if (n == KS_SGR_MOUSE)
-	has_mouse_termcode |= HMT_SGR;
-    else
+                        if (n == KS_SGR_MOUSE)
+                            has_mouse_termcode |= HMT_SGR;
+                        else
 #   endif
-	has_mouse_termcode |= HMT_NORMAL;
+                            has_mouse_termcode |= HMT_NORMAL;
 #  endif
 }
 # endif
 
 # if ((defined(UNIX) || defined(VMS)) \
-	&& defined(FEAT_MOUSE_TTY)) || defined(PROTO)
-    void
+        && defined(FEAT_MOUSE_TTY)) || defined(PROTO)
+void
 del_mouse_termcode(
-    int		n)	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
+        int		n)	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
 {
     char_u	name[2];
 
@@ -2008,35 +2008,35 @@ del_mouse_termcode(
 #  ifdef FEAT_MOUSE_TTY
 #   ifdef FEAT_MOUSE_JSB
     if (n == KS_JSBTERM_MOUSE)
-	has_mouse_termcode &= ~HMT_JSBTERM;
+        has_mouse_termcode &= ~HMT_JSBTERM;
     else
 #   endif
 #   ifdef FEAT_MOUSE_NET
-    if (n == KS_NETTERM_MOUSE)
-	has_mouse_termcode &= ~HMT_NETTERM;
-    else
+        if (n == KS_NETTERM_MOUSE)
+            has_mouse_termcode &= ~HMT_NETTERM;
+        else
 #   endif
 #   ifdef FEAT_MOUSE_DEC
-    if (n == KS_DEC_MOUSE)
-	has_mouse_termcode &= ~HMT_DEC;
-    else
+            if (n == KS_DEC_MOUSE)
+                has_mouse_termcode &= ~HMT_DEC;
+            else
 #   endif
 #   ifdef FEAT_MOUSE_PTERM
-    if (n == KS_PTERM_MOUSE)
-	has_mouse_termcode &= ~HMT_PTERM;
-    else
+                if (n == KS_PTERM_MOUSE)
+                    has_mouse_termcode &= ~HMT_PTERM;
+                else
 #   endif
 #   ifdef FEAT_MOUSE_URXVT
-    if (n == KS_URXVT_MOUSE)
-	has_mouse_termcode &= ~HMT_URXVT;
-    else
+                    if (n == KS_URXVT_MOUSE)
+                        has_mouse_termcode &= ~HMT_URXVT;
+                    else
 #   endif
 #   ifdef FEAT_MOUSE_SGR
-    if (n == KS_SGR_MOUSE)
-	has_mouse_termcode &= ~HMT_SGR;
-    else
+                        if (n == KS_SGR_MOUSE)
+                            has_mouse_termcode &= ~HMT_SGR;
+                        else
 #   endif
-	has_mouse_termcode &= ~HMT_NORMAL;
+                            has_mouse_termcode &= ~HMT_NORMAL;
 #  endif
 }
 # endif
@@ -2055,24 +2055,24 @@ tgetent_error(char_u *tbuf, char_u *term)
     i = TGETENT(tbuf, term);
     if (i < 0		    /* -1 is always an error */
 # ifdef TGETENT_ZERO_ERR
-	    || i == 0	    /* sometimes zero is also an error */
+            || i == 0	    /* sometimes zero is also an error */
 # endif
        )
     {
-	/* On FreeBSD tputs() gets a SEGV after a tgetent() which fails.  Call
-	 * tgetent() with the always existing "dumb" entry to avoid a crash or
-	 * hang. */
-	(void)TGETENT(tbuf, "dumb");
+        /* On FreeBSD tputs() gets a SEGV after a tgetent() which fails.  Call
+         * tgetent() with the always existing "dumb" entry to avoid a crash or
+         * hang. */
+        (void)TGETENT(tbuf, "dumb");
 
-	if (i < 0)
+        if (i < 0)
 # ifdef TGETENT_ZERO_ERR
-	    return (char_u *)_("E557: Cannot open termcap file");
-	if (i == 0)
+            return (char_u *)_("E557: Cannot open termcap file");
+        if (i == 0)
 # endif
 #ifdef TERMINFO
-	    return (char_u *)_("E558: Terminal entry not found in terminfo");
+            return (char_u *)_("E558: Terminal entry not found in terminfo");
 #else
-	    return (char_u *)_("E559: Terminal entry not found in termcap");
+        return (char_u *)_("E559: Terminal entry not found in termcap");
 #endif
     }
     return NULL;
@@ -2089,7 +2089,7 @@ vim_tgetstr(char *s, char_u **pp)
 
     p = tgetstr(s, (char **)pp);
     if (p == (char *)-1)
-	p = NULL;
+        p = NULL;
     return (char_u *)p;
 }
 #endif /* HAVE_TGETENT */
@@ -2101,19 +2101,19 @@ vim_tgetstr(char *s, char_u **pp)
  * and "li" entries never change. But on some systems this works.
  * Errors while getting the entries are ignored.
  */
-    void
+void
 getlinecol(
-    long	*cp,	/* pointer to columns */
-    long	*rp)	/* pointer to rows */
+        long	*cp,	/* pointer to columns */
+        long	*rp)	/* pointer to rows */
 {
     char_u	tbuf[TBUFSZ];
 
     if (T_NAME != NULL && *T_NAME != NUL && tgetent_error(tbuf, T_NAME) == NULL)
     {
-	if (*cp == 0)
-	    *cp = tgetnum("co");
-	if (*rp == 0)
-	    *rp = tgetnum("li");
+        if (*cp == 0)
+            *cp = tgetnum("co");
+        if (*rp == 0)
+            *rp = tgetnum("li");
     }
 }
 #endif /* defined(HAVE_TGETENT) && defined(UNIX) */
@@ -2141,93 +2141,93 @@ add_termcap_entry(char_u *name, int force)
     char_u  *error_msg = NULL;
 #endif
 
-/*
- * If the GUI is running or will start in a moment, we only support the keys
- * that the GUI can produce.
- */
+    /*
+     * If the GUI is running or will start in a moment, we only support the keys
+     * that the GUI can produce.
+     */
 #ifdef FEAT_GUI
     if (gui.in_use || gui.starting)
-	return gui_mch_haskey(name);
+        return gui_mch_haskey(name);
 #endif
 
     if (!force && find_termcode(name) != NULL)	    /* it's already there */
-	return OK;
+        return OK;
 
     term = T_NAME;
     if (term == NULL || *term == NUL)	    /* 'term' not defined yet */
-	return FAIL;
+        return FAIL;
 
     if (term_is_builtin(term))		    /* name starts with "builtin_" */
     {
-	term += 8;
+        term += 8;
 #ifdef HAVE_TGETENT
-	builtin_first = TRUE;
+        builtin_first = TRUE;
 #endif
     }
 #ifdef HAVE_TGETENT
     else
-	builtin_first = p_tbi;
+        builtin_first = p_tbi;
 #endif
 
 #ifdef HAVE_TGETENT
-/*
- * We can get the entry from the builtin termcap and from the external one.
- * If 'ttybuiltin' is on or the terminal name starts with "builtin_", try
- * builtin termcap first.
- * If 'ttybuiltin' is off, try external termcap first.
- */
+    /*
+     * We can get the entry from the builtin termcap and from the external one.
+     * If 'ttybuiltin' is on or the terminal name starts with "builtin_", try
+     * builtin termcap first.
+     * If 'ttybuiltin' is off, try external termcap first.
+     */
     for (i = 0; i < 2; ++i)
     {
-	if ((!builtin_first) == i)
-#endif
-	/*
-	 * Search in builtin termcap
-	 */
-	{
-	    termp = find_builtin_term(term);
-	    if (termp->bt_string != NULL)	/* found it */
-	    {
-		key = TERMCAP2KEY(name[0], name[1]);
-		while (termp->bt_entry != (int)KS_NAME)
-		{
-		    if ((int)termp->bt_entry == key)
-		    {
-			add_termcode(name, (char_u *)termp->bt_string,
-							  term_is_8bit(term));
-			return OK;
-		    }
-		    ++termp;
-		}
-	    }
-	}
+        if ((!builtin_first) == i)
+#endif
+            /*
+             * Search in builtin termcap
+             */
+        {
+            termp = find_builtin_term(term);
+            if (termp->bt_string != NULL)	/* found it */
+            {
+                key = TERMCAP2KEY(name[0], name[1]);
+                while (termp->bt_entry != (int)KS_NAME)
+                {
+                    if ((int)termp->bt_entry == key)
+                    {
+                        add_termcode(name, (char_u *)termp->bt_string,
+                                term_is_8bit(term));
+                        return OK;
+                    }
+                    ++termp;
+                }
+            }
+        }
 #ifdef HAVE_TGETENT
-	else
-	/*
-	 * Search in external termcap
-	 */
-	{
-	    error_msg = tgetent_error(tbuf, term);
-	    if (error_msg == NULL)
-	    {
-		string = TGETSTR((char *)name, &tp);
-		if (string != NULL && *string != NUL)
-		{
-		    add_termcode(name, string, FALSE);
-		    return OK;
-		}
-	    }
-	}
+        else
+            /*
+             * Search in external termcap
+             */
+        {
+            error_msg = tgetent_error(tbuf, term);
+            if (error_msg == NULL)
+            {
+                string = TGETSTR((char *)name, &tp);
+                if (string != NULL && *string != NUL)
+                {
+                    add_termcode(name, string, FALSE);
+                    return OK;
+                }
+            }
+        }
     }
 #endif
 
     if (sourcing_name == NULL)
     {
 #ifdef HAVE_TGETENT
-	if (error_msg != NULL)
-	    EMSG(error_msg);
-	else
+        if (error_msg != NULL)
+            EMSG(error_msg);
+        else
 #endif
-	    EMSG2(_("E436: No \"%s\" entry in termcap"), name);
+            EMSG2(_("E436: No \"%s\" entry in termcap"), name);
     }
     return FAIL;
 }
@@ -2260,12 +2260,12 @@ term_7to8bit(char_u *p)
 {
     if (*p == ESC)
     {
-	if (p[1] == '[')
-	    return CSI;
-	if (p[1] == ']')
-	    return OSC;
-	if (p[1] == 'O')
-	    return 0x8f;
+        if (p[1] == '[')
+            return CSI;
+        if (p[1] == ']')
+            return OSC;
+        if (p[1] == 'O')
+            return 0x8f;
     }
     return 0;
 }
@@ -2290,9 +2290,9 @@ tltoa(unsigned long i)
     *p = '\0';
     do
     {
-	--p;
-	*p = (char_u) (i % 10 + '0');
-	i /= 10;
+        --p;
+        *p = (char_u) (i % 10 + '0');
+        i /= 10;
     }
     while (i > 0 && p > buf);
     return p;
@@ -2314,37 +2314,37 @@ tgoto(char *cm, int x, int y)
     char *p, *s, *e;
 
     if (!cm)
-	return "OOPS";
+        return "OOPS";
     e = buf + 29;
     for (s = buf; s < e && *cm; cm++)
     {
-	if (*cm != '%')
-	{
-	    *s++ = *cm;
-	    continue;
-	}
-	switch (*++cm)
-	{
-	case 'd':
-	    p = (char *)tltoa((unsigned long)y);
-	    y = x;
-	    while (*p)
-		*s++ = *p++;
-	    break;
-	case 'i':
-	    x++;
-	    y++;
-	    break;
-	case '+':
-	    *s++ = (char)(*++cm + y);
-	    y = x;
-	    break;
-	case '%':
-	    *s++ = *cm;
-	    break;
-	default:
-	    return "OOPS";
-	}
+        if (*cm != '%')
+        {
+            *s++ = *cm;
+            continue;
+        }
+        switch (*++cm)
+        {
+            case 'd':
+                p = (char *)tltoa((unsigned long)y);
+                y = x;
+                while (*p)
+                    *s++ = *p++;
+                break;
+            case 'i':
+                x++;
+                y++;
+                break;
+            case '+':
+                *s++ = (char)(*++cm + y);
+                y = x;
+                break;
+            case '%':
+                *s++ = *cm;
+                break;
+            default:
+                return "OOPS";
+        }
     }
     *s = '\0';
     return buf;
@@ -2363,7 +2363,7 @@ termcapinit(char_u *name)
     char_u	*term;
 
     if (name != NULL && *name == NUL)
-	name = NULL;	    /* empty name is equal to no name */
+        name = NULL;	    /* empty name is equal to no name */
     term = name;
 
 #ifdef __BEOS__
@@ -2374,15 +2374,15 @@ termcapinit(char_u *name)
      * been given on the command line.
      */
     if (term == NULL
-		 && strcmp((char *)mch_getenv((char_u *)"TERM"), "ansi") == 0)
-	term = DEFAULT_TERM;
+            && strcmp((char *)mch_getenv((char_u *)"TERM"), "ansi") == 0)
+        term = DEFAULT_TERM;
 #endif
 #ifndef MSWIN
     if (term == NULL)
-	term = mch_getenv((char_u *)"TERM");
+        term = mch_getenv((char_u *)"TERM");
 #endif
     if (term == NULL || *term == NUL)
-	term = DEFAULT_TERM;
+        term = DEFAULT_TERM;
     set_string_option_direct((char_u *)"term", -1, term, OPT_FREE, 0);
 
     /* Set the default terminal name. */
@@ -2403,7 +2403,7 @@ termcapinit(char_u *name)
 #else
 # define OUT_SIZE	2047
 #endif
-	    /* Add one to allow mch_write() in os_win32.c to append a NUL */
+/* Add one to allow mch_write() in os_win32.c to append a NUL */
 static char_u		out_buf[OUT_SIZE + 1];
 static int		out_pos = 0;	/* number of chars in out_buf */
 
@@ -2411,16 +2411,16 @@ static int		out_pos = 0;	/* number of chars in out_buf */
  * out_flush(): flush the output buffer
  */
     void
-out_flush(void)
+        out_flush(void)
 {
     int	    len;
 
     if (out_pos != 0)
     {
-	/* set out_pos to 0 before ui_write, to avoid recursiveness */
-	len = out_pos;
-	out_pos = 0;
-	ui_write(out_buf, len);
+        /* set out_pos to 0 before ui_write, to avoid recursiveness */
+        len = out_pos;
+        out_pos = 0;
+        ui_write(out_buf, len);
     }
 }
 
@@ -2433,7 +2433,7 @@ out_flush(void)
 out_flush_check(void)
 {
     if (enc_dbcs != 0 && out_pos >= OUT_SIZE - MB_MAXBYTES)
-	out_flush();
+        out_flush();
 }
 #endif
 
@@ -2442,7 +2442,7 @@ out_flush_check(void)
  * out_trash(): Throw away the contents of the output buffer
  */
     void
-out_trash(void)
+        out_trash(void)
 {
     out_pos = 0;
 }
@@ -2455,18 +2455,18 @@ out_trash(void)
  * like msg_puts() and screen_putchar() for that).
  */
     void
-out_char(unsigned c)
+        out_char(unsigned c)
 {
 #if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
     if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
-	out_char('\r');
+        out_char('\r');
 #endif
 
     out_buf[out_pos++] = c;
 
     /* For testing we flush each time. */
     if (out_pos >= OUT_SIZE || p_wd)
-	out_flush();
+        out_flush();
 }
 
 static void out_char_nf(unsigned);
@@ -2475,17 +2475,17 @@ static void out_char_nf(unsigned);
  * out_char_nf(c): like out_char(), but don't flush when p_wd is set
  */
     static void
-out_char_nf(unsigned c)
+               out_char_nf(unsigned c)
 {
 #if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
     if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
-	out_char_nf('\r');
+        out_char_nf('\r');
 #endif
 
     out_buf[out_pos++] = c;
 
     if (out_pos >= OUT_SIZE)
-	out_flush();
+        out_flush();
 }
 
 #if defined(FEAT_TITLE) || defined(FEAT_MOUSE_TTY) || defined(FEAT_GUI) \
@@ -2503,13 +2503,13 @@ out_char_nf(unsigned c)
 out_str_nf(char_u *s)
 {
     if (out_pos > OUT_SIZE - 20)  /* avoid terminal strings being split up */
-	out_flush();
+        out_flush();
     while (*s)
-	out_char_nf(*s++);
+        out_char_nf(*s++);
 
     /* For testing we write one string at a time. */
     if (p_wd)
-	out_flush();
+        out_flush();
 }
 #endif
 
@@ -2520,31 +2520,31 @@ out_str_nf(char_u *s)
  * normal text (use functions like msg_puts() and screen_putchar() for that).
  */
     void
-out_str(char_u *s)
+        out_str(char_u *s)
 {
     if (s != NULL && *s)
     {
 #ifdef FEAT_GUI
-	/* Don't use tputs() when GUI is used, ncurses crashes. */
-	if (gui.in_use)
-	{
-	    out_str_nf(s);
-	    return;
-	}
-#endif
-	/* avoid terminal strings being split up */
-	if (out_pos > OUT_SIZE - 20)
-	    out_flush();
+        /* Don't use tputs() when GUI is used, ncurses crashes. */
+        if (gui.in_use)
+        {
+            out_str_nf(s);
+            return;
+        }
+#endif
+        /* avoid terminal strings being split up */
+        if (out_pos > OUT_SIZE - 20)
+            out_flush();
 #ifdef HAVE_TGETENT
-	tputs((char *)s, 1, TPUTSFUNCAST out_char_nf);
+        tputs((char *)s, 1, TPUTSFUNCAST out_char_nf);
 #else
-	while (*s)
-	    out_char_nf(*s++);
+        while (*s)
+            out_char_nf(*s++);
 #endif
 
-	/* For testing we write one string at a time. */
-	if (p_wd)
-	    out_flush();
+        /* For testing we write one string at a time. */
+        if (p_wd)
+            out_flush();
     }
 }
 
@@ -2581,9 +2581,9 @@ term_set_winpos(int x, int y)
 {
     /* Can't handle a negative value here */
     if (x < 0)
-	x = 0;
+        x = 0;
     if (y < 0)
-	y = 0;
+        y = 0;
     OUT_STR(tgoto((char *)T_CWP, y, x));
 }
 
@@ -2599,9 +2599,9 @@ term_fg_color(int n)
 {
     /* Use "AF" termcap entry if present, "Sf" entry otherwise */
     if (*T_CAF)
-	term_color(T_CAF, n);
+        term_color(T_CAF, n);
     else if (*T_CSF)
-	term_color(T_CSF, n);
+        term_color(T_CSF, n);
 }
 
     void
@@ -2609,9 +2609,9 @@ term_bg_color(int n)
 {
     /* Use "AB" termcap entry if present, "Sb" entry otherwise */
     if (*T_CAB)
-	term_color(T_CAB, n);
+        term_color(T_CAB, n);
     else if (*T_CSB)
-	term_color(T_CSB, n);
+        term_color(T_CSB, n);
 }
 
     static void
@@ -2624,25 +2624,25 @@ term_color(char_u *s, int n)
     /* Also accept "\e[3%dm" for TERMINFO, it is sometimes used */
     /* Also accept CSI instead of <Esc>[ */
     if (n >= 8 && t_colors >= 16
-	      && ((s[0] == ESC && s[1] == '[') || (s[0] == CSI && (i = 1) == 1))
-	      && s[i] != NUL
-	      && (STRCMP(s + i + 1, "%p1%dm") == 0
-		  || STRCMP(s + i + 1, "%dm") == 0)
-	      && (s[i] == '3' || s[i] == '4'))
+            && ((s[0] == ESC && s[1] == '[') || (s[0] == CSI && (i = 1) == 1))
+            && s[i] != NUL
+            && (STRCMP(s + i + 1, "%p1%dm") == 0
+                || STRCMP(s + i + 1, "%dm") == 0)
+            && (s[i] == '3' || s[i] == '4'))
     {
 #ifdef TERMINFO
-	char *format = "%s%s%%p1%%dm";
+        char *format = "%s%s%%p1%%dm";
 #else
-	char *format = "%s%s%%dm";
+        char *format = "%s%s%%dm";
 #endif
-	sprintf(buf, format,
-		i == 2 ? IF_EB("\033[", ESC_STR "[") : "\233",
-		s[i] == '3' ? (n >= 16 ? "38;5;" : "9")
-			    : (n >= 16 ? "48;5;" : "10"));
-	OUT_STR(tgoto(buf, 0, n >= 16 ? n : n - 8));
+        sprintf(buf, format,
+                i == 2 ? IF_EB("\033[", ESC_STR "[") : "\233",
+                s[i] == '3' ? (n >= 16 ? "38;5;" : "9")
+                : (n >= 16 ? "48;5;" : "10"));
+        OUT_STR(tgoto(buf, 0, n >= 16 ? n : n - 8));
     }
     else
-	OUT_STR(tgoto((char *)s, 0, n));
+        OUT_STR(tgoto((char *)s, 0, n));
 }
 
 #if defined(FEAT_TERMGUICOLORS) || defined(PROTO)
@@ -2669,13 +2669,13 @@ term_rgb_color(char_u *s, long_u rgb)
     char	buf[MAX_COLOR_STR_LEN];
 
     vim_snprintf(buf, MAX_COLOR_STR_LEN,
-				  (char *)s, RED(rgb), GREEN(rgb), BLUE(rgb));
+            (char *)s, RED(rgb), GREEN(rgb), BLUE(rgb));
     OUT_STR(buf);
 }
 #endif
 
 #if (defined(FEAT_TITLE) && (defined(UNIX) || defined(VMS) \
-	|| defined(MACOS_X))) || defined(PROTO)
+            || defined(MACOS_X))) || defined(PROTO)
 /*
  * Generic function to set window title, using t_ts and t_fs.
  */
@@ -2703,83 +2703,83 @@ ttest(int pairs)
      * MUST have "cm": cursor motion.
      */
     if (*T_CM == NUL)
-	EMSG(_("E437: terminal capability \"cm\" required"));
+        EMSG(_("E437: terminal capability \"cm\" required"));
 
     /*
      * if "cs" defined, use a scroll region, it's faster.
      */
     if (*T_CS != NUL)
-	scroll_region = TRUE;
+        scroll_region = TRUE;
     else
-	scroll_region = FALSE;
+        scroll_region = FALSE;
 
     if (pairs)
     {
-	/*
-	 * optional pairs
-	 */
-	/* TP goes to normal mode for TI (invert) and TB (bold) */
-	if (*T_ME == NUL)
-	    T_ME = T_MR = T_MD = T_MB = empty_option;
-	if (*T_SO == NUL || *T_SE == NUL)
-	    T_SO = T_SE = empty_option;
-	if (*T_US == NUL || *T_UE == NUL)
-	    T_US = T_UE = empty_option;
-	if (*T_CZH == NUL || *T_CZR == NUL)
-	    T_CZH = T_CZR = empty_option;
-
-	/* T_VE is needed even though T_VI is not defined */
-	if (*T_VE == NUL)
-	    T_VI = empty_option;
-
-	/* if 'mr' or 'me' is not defined use 'so' and 'se' */
-	if (*T_ME == NUL)
-	{
-	    T_ME = T_SE;
-	    T_MR = T_SO;
-	    T_MD = T_SO;
-	}
-
-	/* if 'so' or 'se' is not defined use 'mr' and 'me' */
-	if (*T_SO == NUL)
-	{
-	    T_SE = T_ME;
-	    if (*T_MR == NUL)
-		T_SO = T_MD;
-	    else
-		T_SO = T_MR;
-	}
-
-	/* if 'ZH' or 'ZR' is not defined use 'mr' and 'me' */
-	if (*T_CZH == NUL)
-	{
-	    T_CZR = T_ME;
-	    if (*T_MR == NUL)
-		T_CZH = T_MD;
-	    else
-		T_CZH = T_MR;
-	}
-
-	/* "Sb" and "Sf" come in pairs */
-	if (*T_CSB == NUL || *T_CSF == NUL)
-	{
-	    T_CSB = empty_option;
-	    T_CSF = empty_option;
-	}
-
-	/* "AB" and "AF" come in pairs */
-	if (*T_CAB == NUL || *T_CAF == NUL)
-	{
-	    T_CAB = empty_option;
-	    T_CAF = empty_option;
-	}
-
-	/* if 'Sb' and 'AB' are not defined, reset "Co" */
-	if (*T_CSB == NUL && *T_CAB == NUL)
-	    free_one_termoption(T_CCO);
-
-	/* Set 'weirdinvert' according to value of 't_xs' */
-	p_wiv = (*T_XS != NUL);
+        /*
+         * optional pairs
+         */
+        /* TP goes to normal mode for TI (invert) and TB (bold) */
+        if (*T_ME == NUL)
+            T_ME = T_MR = T_MD = T_MB = empty_option;
+        if (*T_SO == NUL || *T_SE == NUL)
+            T_SO = T_SE = empty_option;
+        if (*T_US == NUL || *T_UE == NUL)
+            T_US = T_UE = empty_option;
+        if (*T_CZH == NUL || *T_CZR == NUL)
+            T_CZH = T_CZR = empty_option;
+
+        /* T_VE is needed even though T_VI is not defined */
+        if (*T_VE == NUL)
+            T_VI = empty_option;
+
+        /* if 'mr' or 'me' is not defined use 'so' and 'se' */
+        if (*T_ME == NUL)
+        {
+            T_ME = T_SE;
+            T_MR = T_SO;
+            T_MD = T_SO;
+        }
+
+        /* if 'so' or 'se' is not defined use 'mr' and 'me' */
+        if (*T_SO == NUL)
+        {
+            T_SE = T_ME;
+            if (*T_MR == NUL)
+                T_SO = T_MD;
+            else
+                T_SO = T_MR;
+        }
+
+        /* if 'ZH' or 'ZR' is not defined use 'mr' and 'me' */
+        if (*T_CZH == NUL)
+        {
+            T_CZR = T_ME;
+            if (*T_MR == NUL)
+                T_CZH = T_MD;
+            else
+                T_CZH = T_MR;
+        }
+
+        /* "Sb" and "Sf" come in pairs */
+        if (*T_CSB == NUL || *T_CSF == NUL)
+        {
+            T_CSB = empty_option;
+            T_CSF = empty_option;
+        }
+
+        /* "AB" and "AF" come in pairs */
+        if (*T_CAB == NUL || *T_CAF == NUL)
+        {
+            T_CAB = empty_option;
+            T_CAF = empty_option;
+        }
+
+        /* if 'Sb' and 'AB' are not defined, reset "Co" */
+        if (*T_CSB == NUL && *T_CAB == NUL)
+            free_one_termoption(T_CCO);
+
+        /* Set 'weirdinvert' according to value of 't_xs' */
+        p_wiv = (*T_XS != NUL);
     }
     need_gather = TRUE;
 
@@ -2788,7 +2788,7 @@ ttest(int pairs)
 }
 
 #if (defined(FEAT_GUI) && (defined(FEAT_MENU) || !defined(USE_ON_FLY_SCROLL))) \
-	|| defined(PROTO)
+    || defined(PROTO)
 /*
  * Represent the given long_u as individual bytes, with the most significant
  * byte first, and store them in dst.
@@ -2801,8 +2801,8 @@ add_long_to_buf(long_u val, char_u *dst)
 
     for (i = 1; i <= (int)sizeof(long_u); i++)
     {
-	shift = 8 * (sizeof(long_u) - i);
-	dst[i - 1] = (char_u) ((val >> shift) & 0xff);
+        shift = 8 * (sizeof(long_u) - i);
+        dst[i - 1] = (char_u) ((val >> shift) & 0xff);
     }
 }
 
@@ -2828,11 +2828,11 @@ get_long_from_buf(char_u *buf, long_u *val)
     len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));
     if (len != -1)
     {
-	for (i = 0; i < (int)sizeof(long_u); i++)
-	{
-	    shift = 8 * (sizeof(long_u) - 1 - i);
-	    *val += (long_u)bytes[i] << shift;
-	}
+        for (i = 0; i < (int)sizeof(long_u); i++)
+        {
+            shift = 8 * (sizeof(long_u) - 1 - i);
+            *val += (long_u)bytes[i] << shift;
+        }
     }
     return len;
 }
@@ -2840,7 +2840,7 @@ get_long_from_buf(char_u *buf, long_u *val)
 
 #if defined(FEAT_GUI) \
     || (defined(FEAT_MOUSE) && (!defined(UNIX) || defined(FEAT_MOUSE_XTERM) \
-		|| defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)))
+                || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)))
 /*
  * Read the next num_bytes bytes from buf, and store them in bytes.  Assume
  * that buf has been through inchar().	Returns the actual number of bytes used
@@ -2856,25 +2856,25 @@ get_bytes_from_buf(char_u *buf, char_u *bytes, int num_bytes)
 
     for (i = 0; i < num_bytes; i++)
     {
-	if ((c = buf[len++]) == NUL)
-	    return -1;
-	if (c == K_SPECIAL)
-	{
-	    if (buf[len] == NUL || buf[len + 1] == NUL)	    /* cannot happen? */
-		return -1;
-	    if (buf[len++] == (int)KS_ZERO)
-		c = NUL;
-	    /* else it should be KS_SPECIAL; when followed by KE_FILLER c is
-	     * K_SPECIAL, or followed by KE_CSI and c must be CSI. */
-	    if (buf[len++] == (int)KE_CSI)
-		c = CSI;
-	}
-	else if (c == CSI && buf[len] == KS_EXTRA
-					       && buf[len + 1] == (int)KE_CSI)
-	    /* CSI is stored as CSI KS_SPECIAL KE_CSI to avoid confusion with
-	     * the start of a special key, see add_to_input_buf_csi(). */
-	    len += 2;
-	bytes[i] = c;
+        if ((c = buf[len++]) == NUL)
+            return -1;
+        if (c == K_SPECIAL)
+        {
+            if (buf[len] == NUL || buf[len + 1] == NUL)	    /* cannot happen? */
+                return -1;
+            if (buf[len++] == (int)KS_ZERO)
+                c = NUL;
+            /* else it should be KS_SPECIAL; when followed by KE_FILLER c is
+             * K_SPECIAL, or followed by KE_CSI and c must be CSI. */
+            if (buf[len++] == (int)KE_CSI)
+                c = CSI;
+        }
+        else if (c == CSI && buf[len] == KS_EXTRA
+                && buf[len + 1] == (int)KE_CSI)
+            /* CSI is stored as CSI KS_SPECIAL KE_CSI to avoid confusion with
+             * the start of a special key, see add_to_input_buf_csi(). */
+            len += 2;
+        bytes[i] = c;
     }
     return len;
 }
@@ -2888,7 +2888,7 @@ get_bytes_from_buf(char_u *buf, char_u *bytes, int num_bytes)
 check_shellsize(void)
 {
     if (Rows < min_rows())	/* need room for one window and command line */
-	Rows = min_rows();
+        Rows = min_rows();
     limit_screen_size();
 }
 
@@ -2899,11 +2899,11 @@ check_shellsize(void)
 limit_screen_size(void)
 {
     if (Columns < MIN_COLUMNS)
-	Columns = MIN_COLUMNS;
+        Columns = MIN_COLUMNS;
     else if (Columns > 10000)
-	Columns = 10000;
+        Columns = 10000;
     if (Rows > 1000)
-	Rows = 1000;
+        Rows = 1000;
 }
 
 /*
@@ -2916,20 +2916,20 @@ win_new_shellsize(void)
     static int	old_Columns = 0;
 
     if (old_Rows != Rows || old_Columns != Columns)
-	ui_new_shellsize();
+        ui_new_shellsize();
     if (old_Rows != Rows)
     {
-	/* if 'window' uses the whole screen, keep it using that */
-	if (p_window == old_Rows - 1 || old_Rows == 0)
-	    p_window = Rows - 1;
-	old_Rows = Rows;
-	shell_new_rows();	/* update window sizes */
+        /* if 'window' uses the whole screen, keep it using that */
+        if (p_window == old_Rows - 1 || old_Rows == 0)
+            p_window = Rows - 1;
+        old_Rows = Rows;
+        shell_new_rows();	/* update window sizes */
     }
     if (old_Columns != Columns)
     {
-	old_Columns = Columns;
+        old_Columns = Columns;
 #ifdef FEAT_WINDOWS
-	shell_new_columns();	/* update window sizes */
+        shell_new_columns();	/* update window sizes */
 #endif
     }
 }
@@ -2956,16 +2956,16 @@ shell_resized_check(void)
 
     if (!exiting
 #ifdef FEAT_GUI
-	    /* Do not get the size when executing a shell command during
-	     * startup. */
-	    && !gui.starting
+            /* Do not get the size when executing a shell command during
+             * startup. */
+            && !gui.starting
 #endif
-	    )
+       )
     {
-	(void)ui_get_shellsize();
-	check_shellsize();
-	if (old_Rows != Rows || old_Columns != Columns)
-	    shell_resized();
+        (void)ui_get_shellsize();
+        check_shellsize();
+        if (old_Rows != Rows || old_Columns != Columns)
+            shell_resized();
     }
 }
 
@@ -2986,16 +2986,16 @@ set_shellsize(int width, int height, int mustset)
      * another window-changed signal.
      */
     if (busy)
-	return;
+        return;
 
     if (width < 0 || height < 0)    /* just checking... */
-	return;
+        return;
 
     if (State == HITRETURN || State == SETWSIZE)
     {
-	/* postpone the resizing */
-	State = SETWSIZE;
-	return;
+        /* postpone the resizing */
+        State = SETWSIZE;
+        return;
     }
 
     /* curwin->w_buffer can be NULL when we are closing a window and the
@@ -3003,86 +3003,86 @@ set_shellsize(int width, int height, int mustset)
      * event. Don't resize then, it will happen after entering another buffer.
      */
     if (curwin->w_buffer == NULL)
-	return;
+        return;
 
     ++busy;
 
 #ifdef AMIGA
     out_flush();	    /* must do this before mch_get_shellsize() for
-			       some obscure reason */
+                           some obscure reason */
 #endif
 
     if (mustset || (ui_get_shellsize() == FAIL && height != 0))
     {
-	Rows = height;
-	Columns = width;
-	check_shellsize();
-	ui_set_shellsize(mustset);
+        Rows = height;
+        Columns = width;
+        check_shellsize();
+        ui_set_shellsize(mustset);
     }
     else
-	check_shellsize();
+        check_shellsize();
 
     /* The window layout used to be adjusted here, but it now happens in
      * screenalloc() (also invoked from screenclear()).  That is because the
      * "busy" check above may skip this, but not screenalloc(). */
 
     if (State != ASKMORE && State != EXTERNCMD && State != CONFIRM)
-	screenclear();
+        screenclear();
     else
-	screen_start();	    /* don't know where cursor is now */
+        screen_start();	    /* don't know where cursor is now */
 
     if (starting != NO_SCREEN)
     {
 #ifdef FEAT_TITLE
-	maketitle();
-#endif
-	changed_line_abv_curs();
-	invalidate_botline();
-
-	/*
-	 * We only redraw when it's needed:
-	 * - While at the more prompt or executing an external command, don't
-	 *   redraw, but position the cursor.
-	 * - While editing the command line, only redraw that.
-	 * - in Ex mode, don't redraw anything.
-	 * - Otherwise, redraw right now, and position the cursor.
-	 * Always need to call update_screen() or screenalloc(), to make
-	 * sure Rows/Columns and the size of ScreenLines[] is correct!
-	 */
-	if (State == ASKMORE || State == EXTERNCMD || State == CONFIRM
-							     || exmode_active)
-	{
-	    screenalloc(FALSE);
-	    repeat_message();
-	}
-	else
-	{
+        maketitle();
+#endif
+        changed_line_abv_curs();
+        invalidate_botline();
+
+        /*
+         * We only redraw when it's needed:
+         * - While at the more prompt or executing an external command, don't
+         *   redraw, but position the cursor.
+         * - While editing the command line, only redraw that.
+         * - in Ex mode, don't redraw anything.
+         * - Otherwise, redraw right now, and position the cursor.
+         * Always need to call update_screen() or screenalloc(), to make
+         * sure Rows/Columns and the size of ScreenLines[] is correct!
+         */
+        if (State == ASKMORE || State == EXTERNCMD || State == CONFIRM
+                || exmode_active)
+        {
+            screenalloc(FALSE);
+            repeat_message();
+        }
+        else
+        {
 #ifdef FEAT_SCROLLBIND
-	    if (curwin->w_p_scb)
-		do_check_scrollbind(TRUE);
-#endif
-	    if (State & CMDLINE)
-	    {
-		update_screen(NOT_VALID);
-		redrawcmdline();
-	    }
-	    else
-	    {
-		update_topline();
+            if (curwin->w_p_scb)
+                do_check_scrollbind(TRUE);
+#endif
+            if (State & CMDLINE)
+            {
+                update_screen(NOT_VALID);
+                redrawcmdline();
+            }
+            else
+            {
+                update_topline();
 #if defined(FEAT_INS_EXPAND)
-		if (pum_visible())
-		{
-		    redraw_later(NOT_VALID);
-		    ins_compl_show_pum(); /* This includes the redraw. */
-		}
-		else
-#endif
-		    update_screen(NOT_VALID);
-		if (redrawing())
-		    setcursor();
-	    }
-	}
-	cursor_on();	    /* redrawing may have switched it off */
+                if (pum_visible())
+                {
+                    redraw_later(NOT_VALID);
+                    ins_compl_show_pum(); /* This includes the redraw. */
+                }
+                else
+#endif
+                    update_screen(NOT_VALID);
+                if (redrawing())
+                    setcursor();
+            }
+        }
+        cursor_on();	    /* redrawing may have switched it off */
     }
     out_flush();
     --busy;
@@ -3098,51 +3098,51 @@ settmode(int tmode)
 #ifdef FEAT_GUI
     /* don't set the term where gvim was started to any mode */
     if (gui.in_use)
-	return;
+        return;
 #endif
 
     if (full_screen)
     {
-	/*
-	 * When returning after calling a shell we want to really set the
-	 * terminal to raw mode, even though we think it already is, because
-	 * the shell program may have reset the terminal mode.
-	 * When we think the terminal is normal, don't try to set it to
-	 * normal again, because that causes problems (logout!) on some
-	 * machines.
-	 */
-	if (tmode != TMODE_COOK || cur_tmode != TMODE_COOK)
-	{
+        /*
+         * When returning after calling a shell we want to really set the
+         * terminal to raw mode, even though we think it already is, because
+         * the shell program may have reset the terminal mode.
+         * When we think the terminal is normal, don't try to set it to
+         * normal again, because that causes problems (logout!) on some
+         * machines.
+         */
+        if (tmode != TMODE_COOK || cur_tmode != TMODE_COOK)
+        {
 #ifdef FEAT_TERMRESPONSE
 # ifdef FEAT_GUI
-	    if (!gui.in_use && !gui.starting)
+            if (!gui.in_use && !gui.starting)
 # endif
-	    {
-		/* May need to check for T_CRV response and termcodes, it
-		 * doesn't work in Cooked mode, an external program may get
-		 * them. */
-		if (tmode != TMODE_RAW && (crv_status == CRV_SENT
-					 || u7_status == U7_SENT
-					 || rbg_status == RBG_SENT))
-		    (void)vpeekc_nomap();
-		check_for_codes_from_term();
-	    }
+            {
+                /* May need to check for T_CRV response and termcodes, it
+                 * doesn't work in Cooked mode, an external program may get
+                 * them. */
+                if (tmode != TMODE_RAW && (crv_status == CRV_SENT
+                            || u7_status == U7_SENT
+                            || rbg_status == RBG_SENT))
+                    (void)vpeekc_nomap();
+                check_for_codes_from_term();
+            }
 #endif
 #ifdef FEAT_MOUSE_TTY
-	    if (tmode != TMODE_RAW)
-		mch_setmouse(FALSE);		/* switch mouse off */
+            if (tmode != TMODE_RAW)
+                mch_setmouse(FALSE);		/* switch mouse off */
 #endif
-	    out_flush();
-	    mch_settmode(tmode);    /* machine specific function */
-	    cur_tmode = tmode;
+            out_flush();
+            mch_settmode(tmode);    /* machine specific function */
+            cur_tmode = tmode;
 #ifdef FEAT_MOUSE
-	    if (tmode == TMODE_RAW)
-		setmouse();			/* may switch mouse on */
+            if (tmode == TMODE_RAW)
+                setmouse();			/* may switch mouse on */
 #endif
-	    out_flush();
-	}
+            out_flush();
+        }
 #ifdef FEAT_TERMRESPONSE
-	may_req_termresponse();
+        may_req_termresponse();
 #endif
     }
 }
@@ -3152,22 +3152,22 @@ starttermcap(void)
 {
     if (full_screen && !termcap_active)
     {
-	out_str(T_TI);			/* start termcap mode */
-	out_str(T_KS);			/* start "keypad transmit" mode */
-	out_flush();
-	termcap_active = TRUE;
-	screen_start();			/* don't know where cursor is now */
+        out_str(T_TI);			/* start termcap mode */
+        out_str(T_KS);			/* start "keypad transmit" mode */
+        out_flush();
+        termcap_active = TRUE;
+        screen_start();			/* don't know where cursor is now */
 #ifdef FEAT_TERMRESPONSE
 # ifdef FEAT_GUI
-	if (!gui.in_use && !gui.starting)
+        if (!gui.in_use && !gui.starting)
 # endif
-	{
-	    may_req_termresponse();
-	    /* Immediately check for a response.  If t_Co changes, we don't
-	     * want to redraw with wrong colors first. */
-	    if (crv_status == CRV_SENT)
-		check_for_codes_from_term();
-	}
+        {
+            may_req_termresponse();
+            /* Immediately check for a response.  If t_Co changes, we don't
+             * want to redraw with wrong colors first. */
+            if (crv_status == CRV_SENT)
+                check_for_codes_from_term();
+        }
 #endif
     }
 }
@@ -3181,35 +3181,35 @@ stoptermcap(void)
     {
 #ifdef FEAT_TERMRESPONSE
 # ifdef FEAT_GUI
-	if (!gui.in_use && !gui.starting)
+        if (!gui.in_use && !gui.starting)
 # endif
-	{
-	    /* May need to discard T_CRV, T_U7 or T_RBG response. */
-	    if (crv_status == CRV_SENT || u7_status == U7_SENT
-						     || rbg_status == RBG_SENT)
-	    {
+        {
+            /* May need to discard T_CRV, T_U7 or T_RBG response. */
+            if (crv_status == CRV_SENT || u7_status == U7_SENT
+                    || rbg_status == RBG_SENT)
+            {
 # ifdef UNIX
-		/* Give the terminal a chance to respond. */
-		mch_delay(100L, FALSE);
+                /* Give the terminal a chance to respond. */
+                mch_delay(100L, FALSE);
 # endif
 # ifdef TCIFLUSH
-		/* Discard data received but not read. */
-		if (exiting)
-		    tcflush(fileno(stdin), TCIFLUSH);
+                /* Discard data received but not read. */
+                if (exiting)
+                    tcflush(fileno(stdin), TCIFLUSH);
 # endif
-	    }
-	    /* Check for termcodes first, otherwise an external program may
-	     * get them. */
-	    check_for_codes_from_term();
-	}
-#endif
-	out_str(T_KE);			/* stop "keypad transmit" mode */
-	out_flush();
-	termcap_active = FALSE;
-	cursor_on();			/* just in case it is still off */
-	out_str(T_TE);			/* stop termcap mode */
-	screen_start();			/* don't know where cursor is now */
-	out_flush();
+            }
+            /* Check for termcodes first, otherwise an external program may
+             * get them. */
+            check_for_codes_from_term();
+        }
+#endif
+        out_str(T_KE);			/* stop "keypad transmit" mode */
+        out_flush();
+        termcap_active = FALSE;
+        cursor_on();			/* just in case it is still off */
+        out_str(T_TE);			/* stop termcap mode */
+        screen_start();			/* don't know where cursor is now */
+        out_flush();
     }
 }
 
@@ -3232,23 +3232,23 @@ stoptermcap(void)
 may_req_termresponse(void)
 {
     if (crv_status == CRV_GET
-	    && cur_tmode == TMODE_RAW
-	    && starting == 0
-	    && termcap_active
-	    && p_ek
+            && cur_tmode == TMODE_RAW
+            && starting == 0
+            && termcap_active
+            && p_ek
 # ifdef UNIX
-	    && isatty(1)
-	    && isatty(read_cmd_fd)
+            && isatty(1)
+            && isatty(read_cmd_fd)
 # endif
-	    && *T_CRV != NUL)
+            && *T_CRV != NUL)
     {
-	LOG_TR("Sending CRV");
-	out_str(T_CRV);
-	crv_status = CRV_SENT;
-	/* check for the characters now, otherwise they might be eaten by
-	 * get_keystroke() */
-	out_flush();
-	(void)vpeekc_nomap();
+        LOG_TR("Sending CRV");
+        out_str(T_CRV);
+        crv_status = CRV_SENT;
+        /* check for the characters now, otherwise they might be eaten by
+         * get_keystroke() */
+        out_flush();
+        (void)vpeekc_nomap();
     }
 }
 
@@ -3266,34 +3266,34 @@ may_req_termresponse(void)
 may_req_ambiguous_char_width(void)
 {
     if (u7_status == U7_GET
-	    && cur_tmode == TMODE_RAW
-	    && termcap_active
-	    && p_ek
+            && cur_tmode == TMODE_RAW
+            && termcap_active
+            && p_ek
 #  ifdef UNIX
-	    && isatty(1)
-	    && isatty(read_cmd_fd)
+            && isatty(1)
+            && isatty(read_cmd_fd)
 #  endif
-	    && *T_U7 != NUL
-	    && !option_was_set((char_u *)"ambiwidth"))
+            && *T_U7 != NUL
+            && !option_was_set((char_u *)"ambiwidth"))
     {
-	 char_u	buf[16];
-
-	 LOG_TR("Sending U7 request");
-	 /* Do this in the second row.  In the first row the returned sequence
-	  * may be CSI 1;2R, which is the same as <S-F3>. */
-	 term_windgoto(1, 0);
-	 buf[mb_char2bytes(0x25bd, buf)] = 0;
-	 out_str(buf);
-	 out_str(T_U7);
-	 u7_status = U7_SENT;
-	 out_flush();
-	 term_windgoto(1, 0);
-	 out_str((char_u *)"  ");
-	 term_windgoto(0, 0);
-	 /* check for the characters now, otherwise they might be eaten by
-	  * get_keystroke() */
-	 out_flush();
-	 (void)vpeekc_nomap();
+        char_u	buf[16];
+
+        LOG_TR("Sending U7 request");
+        /* Do this in the second row.  In the first row the returned sequence
+         * may be CSI 1;2R, which is the same as <S-F3>. */
+        term_windgoto(1, 0);
+        buf[mb_char2bytes(0x25bd, buf)] = 0;
+        out_str(buf);
+        out_str(T_U7);
+        u7_status = U7_SENT;
+        out_flush();
+        term_windgoto(1, 0);
+        out_str((char_u *)"  ");
+        term_windgoto(0, 0);
+        /* check for the characters now, otherwise they might be eaten by
+         * get_keystroke() */
+        out_flush();
+        (void)vpeekc_nomap();
     }
 }
 # endif
@@ -3307,23 +3307,23 @@ may_req_ambiguous_char_width(void)
 may_req_bg_color(void)
 {
     if (rbg_status == RBG_GET
-	    && cur_tmode == TMODE_RAW
-	    && termcap_active
-	    && p_ek
+            && cur_tmode == TMODE_RAW
+            && termcap_active
+            && p_ek
 #  ifdef UNIX
-	    && isatty(1)
-	    && isatty(read_cmd_fd)
+            && isatty(1)
+            && isatty(read_cmd_fd)
 #  endif
-	    && *T_RBG != NUL
-	    && !option_was_set((char_u *)"bg"))
+            && *T_RBG != NUL
+            && !option_was_set((char_u *)"bg"))
     {
-	LOG_TR("Sending BG request");
-	out_str(T_RBG);
-	rbg_status = RBG_SENT;
-	/* check for the characters now, otherwise they might be eaten by
-	 * get_keystroke() */
-	out_flush();
-	(void)vpeekc_nomap();
+        LOG_TR("Sending BG request");
+        out_str(T_RBG);
+        rbg_status = RBG_SENT;
+        /* check for the characters now, otherwise they might be eaten by
+         * get_keystroke() */
+        out_flush();
+        (void)vpeekc_nomap();
     }
 }
 # endif
@@ -3338,16 +3338,16 @@ log_tr(char *msg)
 
     if (fd_tr == NULL)
     {
-	fd_tr = fopen("termresponse.log", "w");
-	profile_start(&start);
+        fd_tr = fopen("termresponse.log", "w");
+        profile_start(&start);
     }
     now = start;
     profile_end(&now);
     fprintf(fd_tr, "%s: %s %s\n",
-	    profile_msg(&now),
-	    must_redraw == NOT_VALID ? "NV"
-					 : must_redraw == CLEAR ? "CL" : "  ",
-	    msg);
+            profile_msg(&now),
+            must_redraw == NOT_VALID ? "NV"
+            : must_redraw == CLEAR ? "CL" : "  ",
+            msg);
 }
 # endif
 #endif
@@ -3380,36 +3380,36 @@ setmouse(void)
 #  ifdef FEAT_GUI
     /* In the GUI the mouse is always enabled. */
     if (gui.in_use)
-	return;
+        return;
 #  endif
     /* be quick when mouse is off */
     if (*p_mouse == NUL || has_mouse_termcode == 0)
-	return;
+        return;
 
     /* don't switch mouse on when not in raw mode (Ex mode) */
     if (cur_tmode != TMODE_RAW)
     {
-	mch_setmouse(FALSE);
-	return;
+        mch_setmouse(FALSE);
+        return;
     }
 
     if (VIsual_active)
-	checkfor = MOUSE_VISUAL;
+        checkfor = MOUSE_VISUAL;
     else if (State == HITRETURN || State == ASKMORE || State == SETWSIZE)
-	checkfor = MOUSE_RETURN;
+        checkfor = MOUSE_RETURN;
     else if (State & INSERT)
-	checkfor = MOUSE_INSERT;
+        checkfor = MOUSE_INSERT;
     else if (State & CMDLINE)
-	checkfor = MOUSE_COMMAND;
+        checkfor = MOUSE_COMMAND;
     else if (State == CONFIRM || State == EXTERNCMD)
-	checkfor = ' '; /* don't use mouse for ":confirm" or ":!cmd" */
+        checkfor = ' '; /* don't use mouse for ":confirm" or ":!cmd" */
     else
-	checkfor = MOUSE_NORMAL;    /* assume normal mode */
+        checkfor = MOUSE_NORMAL;    /* assume normal mode */
 
     if (mouse_has(checkfor))
-	mch_setmouse(TRUE);
+        mch_setmouse(TRUE);
     else
-	mch_setmouse(FALSE);
+        mch_setmouse(FALSE);
 # endif
 }
 
@@ -3426,16 +3426,16 @@ mouse_has(int c)
     char_u	*p;
 
     for (p = p_mouse; *p; ++p)
-	switch (*p)
-	{
-	    case 'a': if (vim_strchr((char_u *)MOUSE_A, c) != NULL)
-			  return TRUE;
-		      break;
-	    case MOUSE_HELP: if (c != MOUSE_RETURN && curbuf->b_help)
-				 return TRUE;
-			     break;
-	    default: if (c == *p) return TRUE; break;
-	}
+        switch (*p)
+        {
+            case 'a': if (vim_strchr((char_u *)MOUSE_A, c) != NULL)
+                          return TRUE;
+                      break;
+            case MOUSE_HELP: if (c != MOUSE_RETURN && curbuf->b_help)
+                                 return TRUE;
+                             break;
+            default: if (c == *p) return TRUE; break;
+        }
     return FALSE;
 }
 
@@ -3459,9 +3459,9 @@ scroll_start(void)
 {
     if (*T_VS != NUL)
     {
-	out_str(T_VS);
-	out_str(T_VE);
-	screen_start();			/* don't know where cursor is now */
+        out_str(T_VS);
+        out_str(T_VE);
+        screen_start();			/* don't know where cursor is now */
     }
 }
 
@@ -3475,8 +3475,8 @@ cursor_on(void)
 {
     if (cursor_is_off)
     {
-	out_str(T_VE);
-	cursor_is_off = FALSE;
+        out_str(T_VE);
+        cursor_is_off = FALSE;
     }
 }
 
@@ -3488,9 +3488,9 @@ cursor_off(void)
 {
     if (full_screen)
     {
-	if (!cursor_is_off)
-	    out_str(T_VI);	    /* disable cursor */
-	cursor_is_off = TRUE;
+        if (!cursor_is_off)
+            out_str(T_VI);	    /* disable cursor */
+        cursor_is_off = TRUE;
     }
 }
 
@@ -3507,35 +3507,35 @@ term_cursor_shape(void)
     /* Only do something when redrawing the screen and we can restore the
      * mode. */
     if (!full_screen || *T_CEI == NUL)
-	return;
+        return;
 
     if ((State & REPLACE) == REPLACE)
     {
-	if (showing_mode != REPLACE)
-	{
-	    if (*T_CSR != NUL)
-		p = T_CSR;	/* Replace mode cursor */
-	    else
-		p = T_CSI;	/* fall back to Insert mode cursor */
-	    if (*p != NUL)
-	    {
-		out_str(p);
-		showing_mode = REPLACE;
-	    }
-	}
+        if (showing_mode != REPLACE)
+        {
+            if (*T_CSR != NUL)
+                p = T_CSR;	/* Replace mode cursor */
+            else
+                p = T_CSI;	/* fall back to Insert mode cursor */
+            if (*p != NUL)
+            {
+                out_str(p);
+                showing_mode = REPLACE;
+            }
+        }
     }
     else if (State & INSERT)
     {
-	if (showing_mode != INSERT && *T_CSI != NUL)
-	{
-	    out_str(T_CSI);	    /* Insert mode cursor */
-	    showing_mode = INSERT;
-	}
+        if (showing_mode != INSERT && *T_CSI != NUL)
+        {
+            out_str(T_CSI);	    /* Insert mode cursor */
+            showing_mode = INSERT;
+        }
     }
     else if (showing_mode != NORMAL)
     {
-	out_str(T_CEI);		    /* non-Insert mode cursor */
-	showing_mode = NORMAL;
+        out_str(T_CEI);		    /* non-Insert mode cursor */
+        showing_mode = NORMAL;
     }
 }
 #endif
@@ -3550,11 +3550,11 @@ term_cursor_shape(void)
 scroll_region_set(win_T *wp, int off)
 {
     OUT_STR(tgoto((char *)T_CS, W_WINROW(wp) + wp->w_height - 1,
-							 W_WINROW(wp) + off));
+                W_WINROW(wp) + off));
 #ifdef FEAT_WINDOWS
     if (*T_CSV != NUL && wp->w_width != Columns)
-	OUT_STR(tgoto((char *)T_CSV, W_WINCOL(wp) + wp->w_width - 1,
-							       W_WINCOL(wp)));
+        OUT_STR(tgoto((char *)T_CSV, W_WINCOL(wp) + wp->w_width - 1,
+                    W_WINCOL(wp)));
 #endif
     screen_start();		    /* don't know where cursor is now */
 }
@@ -3568,7 +3568,7 @@ scroll_region_reset(void)
     OUT_STR(tgoto((char *)T_CS, (int)Rows - 1, 0));
 #ifdef FEAT_WINDOWS
     if (*T_CSV != NUL)
-	OUT_STR(tgoto((char *)T_CSV, (int)Columns - 1, 0));
+        OUT_STR(tgoto((char *)T_CSV, (int)Columns - 1, 0));
 #endif
     screen_start();		    /* don't know where cursor is now */
 }
@@ -3595,7 +3595,7 @@ static int termcode_star(char_u *code, int len);
 clear_termcodes(void)
 {
     while (tc_len > 0)
-	vim_free(termcodes[--tc_len].code);
+        vim_free(termcodes[--tc_len].code);
     vim_free(termcodes);
     termcodes = NULL;
     tc_max_len = 0;
@@ -3628,8 +3628,8 @@ add_termcode(char_u *name, char_u *string, int flags)
 
     if (string == NULL || *string == NUL)
     {
-	del_termcode(name);
-	return;
+        del_termcode(name);
+        return;
     }
 
 #if defined(WIN3264) && !defined(FEAT_GUI)
@@ -3638,20 +3638,20 @@ add_termcode(char_u *name, char_u *string, int flags)
     s = vim_strsave(string);
 #endif
     if (s == NULL)
-	return;
+        return;
 
     /* Change leading <Esc>[ to CSI, change <Esc>O to <M-O>. */
     if (flags != 0 && flags != ATC_FROM_TERM && term_7to8bit(string) != 0)
     {
-	STRMOVE(s, s + 1);
-	s[0] = term_7to8bit(string);
+        STRMOVE(s, s + 1);
+        s[0] = term_7to8bit(string);
     }
 
 #if defined(WIN3264) && !defined(FEAT_GUI)
     if (s[0] == K_NUL)
     {
-	STRMOVE(s + 1, s);
-	s[1] = 3;
+        STRMOVE(s + 1, s);
+        s[1] = 3;
     }
 #endif
 
@@ -3664,18 +3664,18 @@ add_termcode(char_u *name, char_u *string, int flags)
      */
     if (tc_len == tc_max_len)
     {
-	tc_max_len += 20;
-	new_tc = (struct termcode *)alloc(
-			    (unsigned)(tc_max_len * sizeof(struct termcode)));
-	if (new_tc == NULL)
-	{
-	    tc_max_len -= 20;
-	    return;
-	}
-	for (i = 0; i < tc_len; ++i)
-	    new_tc[i] = termcodes[i];
-	vim_free(termcodes);
-	termcodes = new_tc;
+        tc_max_len += 20;
+        new_tc = (struct termcode *)alloc(
+                (unsigned)(tc_max_len * sizeof(struct termcode)));
+        if (new_tc == NULL)
+        {
+            tc_max_len -= 20;
+            return;
+        }
+        for (i = 0; i < tc_len; ++i)
+            new_tc[i] = termcodes[i];
+        vim_free(termcodes);
+        termcodes = new_tc;
     }
 
     /*
@@ -3685,47 +3685,47 @@ add_termcode(char_u *name, char_u *string, int flags)
      */
     for (i = 0; i < tc_len; ++i)
     {
-	if (termcodes[i].name[0] < name[0])
-	    continue;
-	if (termcodes[i].name[0] == name[0])
-	{
-	    if (termcodes[i].name[1] < name[1])
-		continue;
-	    /*
-	     * Exact match: May replace old code.
-	     */
-	    if (termcodes[i].name[1] == name[1])
-	    {
-		if (flags == ATC_FROM_TERM && (j = termcode_star(
-				    termcodes[i].code, termcodes[i].len)) > 0)
-		{
-		    /* Don't replace ESC[123;*X or ESC O*X with another when
-		     * invoked from got_code_from_term(). */
-		    if (len == termcodes[i].len - j
-			    && STRNCMP(s, termcodes[i].code, len - 1) == 0
-			    && s[len - 1]
-				   == termcodes[i].code[termcodes[i].len - 1])
-		    {
-			/* They are equal but for the ";*": don't add it. */
-			vim_free(s);
-			return;
-		    }
-		}
-		else
-		{
-		    /* Replace old code. */
-		    vim_free(termcodes[i].code);
-		    --tc_len;
-		    break;
-		}
-	    }
-	}
-	/*
-	 * Found alphabetical larger entry, move rest to insert new entry
-	 */
-	for (j = tc_len; j > i; --j)
-	    termcodes[j] = termcodes[j - 1];
-	break;
+        if (termcodes[i].name[0] < name[0])
+            continue;
+        if (termcodes[i].name[0] == name[0])
+        {
+            if (termcodes[i].name[1] < name[1])
+                continue;
+            /*
+             * Exact match: May replace old code.
+             */
+            if (termcodes[i].name[1] == name[1])
+            {
+                if (flags == ATC_FROM_TERM && (j = termcode_star(
+                                termcodes[i].code, termcodes[i].len)) > 0)
+                {
+                    /* Don't replace ESC[123;*X or ESC O*X with another when
+                     * invoked from got_code_from_term(). */
+                    if (len == termcodes[i].len - j
+                            && STRNCMP(s, termcodes[i].code, len - 1) == 0
+                            && s[len - 1]
+                            == termcodes[i].code[termcodes[i].len - 1])
+                    {
+                        /* They are equal but for the ";*": don't add it. */
+                        vim_free(s);
+                        return;
+                    }
+                }
+                else
+                {
+                    /* Replace old code. */
+                    vim_free(termcodes[i].code);
+                    --tc_len;
+                    break;
+                }
+            }
+        }
+        /*
+         * Found alphabetical larger entry, move rest to insert new entry
+         */
+        for (j = tc_len; j > i; --j)
+            termcodes[j] = termcodes[j - 1];
+        break;
     }
 
     termcodes[i].name[0] = name[0];
@@ -3738,7 +3738,7 @@ add_termcode(char_u *name, char_u *string, int flags)
     termcodes[i].modlen = 0;
     j = termcode_star(s, len);
     if (j > 0)
-	termcodes[i].modlen = len - 1 - j;
+        termcodes[i].modlen = len - 1 - j;
     ++tc_len;
 }
 
@@ -3753,10 +3753,10 @@ termcode_star(char_u *code, int len)
     /* Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X */
     if (len >= 3 && code[len - 2] == '*')
     {
-	if (len >= 5 && code[len - 3] == ';')
-	    return 2;
-	if ((len >= 4 && code[len - 3] == 'O') || code[len - 3] == 'O' + 128)
-	    return 1;
+        if (len >= 5 && code[len - 3] == ';')
+            return 2;
+        if ((len >= 4 && code[len - 3] == 'O') || code[len - 3] == 'O' + 128)
+            return 1;
     }
     return 0;
 }
@@ -3767,8 +3767,8 @@ find_termcode(char_u *name)
     int	    i;
 
     for (i = 0; i < tc_len; ++i)
-	if (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])
-	    return termcodes[i].code;
+        if (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])
+            return termcodes[i].code;
     return NULL;
 }
 
@@ -3777,7 +3777,7 @@ find_termcode(char_u *name)
 get_termcode(int i)
 {
     if (i >= tc_len)
-	return NULL;
+        return NULL;
     return &termcodes[i].name[0];
 }
 #endif
@@ -3788,16 +3788,16 @@ del_termcode(char_u *name)
     int	    i;
 
     if (termcodes == NULL)	/* nothing there yet */
-	return;
+        return;
 
     need_gather = TRUE;		/* need to fill termleader[] */
 
     for (i = 0; i < tc_len; ++i)
-	if (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])
-	{
-	    del_termcode_idx(i);
-	    return;
-	}
+        if (termcodes[i].name[0] == name[0] && termcodes[i].name[1] == name[1])
+        {
+            del_termcode_idx(i);
+            return;
+        }
     /* not found. Give error message? */
 }
 
@@ -3809,7 +3809,7 @@ del_termcode_idx(int idx)
     vim_free(termcodes[idx].code);
     --tc_len;
     for (i = idx; i < tc_len; ++i)
-	termcodes[i] = termcodes[i + 1];
+        termcodes[i] = termcodes[i + 1];
 }
 
 #ifdef FEAT_TERMRESPONSE
@@ -3826,16 +3826,16 @@ switch_to_8bit(void)
     /* Only need to do something when not already using 8-bit codes. */
     if (!term_is_8bit(T_NAME))
     {
-	for (i = 0; i < tc_len; ++i)
-	{
-	    c = term_7to8bit(termcodes[i].code);
-	    if (c != 0)
-	    {
-		STRMOVE(termcodes[i].code + 1, termcodes[i].code + 2);
-		termcodes[i].code[0] = c;
-	    }
-	}
-	need_gather = TRUE;		/* need to fill termleader[] */
+        for (i = 0; i < tc_len; ++i)
+        {
+            c = term_7to8bit(termcodes[i].code);
+            if (c != 0)
+            {
+                STRMOVE(termcodes[i].code + 1, termcodes[i].code + 2);
+                termcodes[i].code[0] = c;
+            }
+        }
+        need_gather = TRUE;		/* need to fill termleader[] */
     }
     detected_8bit = TRUE;
     LOG_TR("Switching to 8 bit");
@@ -3868,6 +3868,19 @@ set_mouse_topline(win_T *wp)
 }
 #endif
 
+
+
+
+static void lp(char *filename, char *fmt, ...)
+{
+    FILE *f = fopen(filename, "a");
+    va_list args;
+    va_start(args, fmt);
+    vfprintf(f, fmt, args);
+    va_end(args);
+    fclose(f);
+}
+
 /*
  * Check if typebuf.tb_buf[] contains a terminal key code.
  * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off
@@ -3881,12 +3894,12 @@ set_mouse_topline(win_T *wp)
  * "buflen" is then the length of the string in buf[] and is updated for
  * inserts and deletes.
  */
-    int
+int
 check_termcode(
-    int		max_offset,
-    char_u	*buf,
-    int		bufsize,
-    int		*buflen)
+        int		max_offset,
+        char_u	*buf,
+        int		bufsize,
+        int		*buflen)
 {
     char_u	*tp;
     char_u	*p;
@@ -3920,7 +3933,7 @@ check_termcode(
     static int	orig_mouse_col = 0;
     static int	orig_mouse_row = 0;
     static struct timeval  orig_mouse_time = {0, 0};
-					/* time of previous mouse click */
+    /* time of previous mouse click */
     struct timeval  mouse_time;		/* time of current mouse click */
     long	timediff;		/* elapsed time in msec */
 # endif
@@ -3937,7 +3950,7 @@ check_termcode(
      * used in termleader[].  Often this is just a single <Esc>.
      */
     if (need_gather)
-	gather_termleader();
+        gather_termleader();
 
     /*
      * Check at several positions in typebuf.tb_buf[], to catch something like
@@ -3948,1389 +3961,1386 @@ check_termcode(
      */
     for (offset = 0; offset < max_offset; ++offset)
     {
-	if (buf == NULL)
-	{
-	    if (offset >= typebuf.tb_len)
-		break;
-	    tp = typebuf.tb_buf + typebuf.tb_off + offset;
-	    len = typebuf.tb_len - offset;	/* length of the input */
-	}
-	else
-	{
-	    if (offset >= *buflen)
-		break;
-	    tp = buf + offset;
-	    len = *buflen - offset;
-	}
-
-	/*
-	 * Don't check characters after K_SPECIAL, those are already
-	 * translated terminal chars (avoid translating ~@^Hx).
-	 */
-	if (*tp == K_SPECIAL)
-	{
-	    offset += 2;	/* there are always 2 extra characters */
-	    continue;
-	}
-
-	/*
-	 * Skip this position if the character does not appear as the first
-	 * character in term_strings. This speeds up a lot, since most
-	 * termcodes start with the same character (ESC or CSI).
-	 */
-	i = *tp;
-	for (p = termleader; *p && *p != i; ++p)
-	    ;
-	if (*p == NUL)
-	    continue;
-
-	/*
-	 * Skip this position if p_ek is not set and tp[0] is an ESC and we
-	 * are in Insert mode.
-	 */
-	if (*tp == ESC && !p_ek && (State & INSERT))
-	    continue;
-
-	key_name[0] = NUL;	/* no key name found yet */
-	key_name[1] = NUL;	/* no key name found yet */
-	modifiers = 0;		/* no modifiers yet */
+        if (buf == NULL)
+        {
+            if (offset >= typebuf.tb_len)
+                break;
+            tp = typebuf.tb_buf + typebuf.tb_off + offset;
+            len = typebuf.tb_len - offset;	/* length of the input */
+        }
+        else
+        {
+            if (offset >= *buflen)
+                break;
+            tp = buf + offset;
+            len = *buflen - offset;
+        }
+
+        /*
+         * Don't check characters after K_SPECIAL, those are already
+         * translated terminal chars (avoid translating ~@^Hx).
+         */
+        if (*tp == K_SPECIAL)
+        {
+            offset += 2;	/* there are always 2 extra characters */
+            continue;
+        }
+
+        /*
+         * Skip this position if the character does not appear as the first
+         * character in term_strings. This speeds up a lot, since most
+         * termcodes start with the same character (ESC or CSI).
+         */
+        i = *tp;
+        for (p = termleader; *p && *p != i; ++p)
+            ;
+        if (*p == NUL)
+            continue;
+
+        /*
+         * Skip this position if p_ek is not set and tp[0] is an ESC and we
+         * are in Insert mode.
+         */
+        if (*tp == ESC && !p_ek && (State & INSERT))
+            continue;
+
+        key_name[0] = NUL;	/* no key name found yet */
+        key_name[1] = NUL;	/* no key name found yet */
+        modifiers = 0;		/* no modifiers yet */
 
 #ifdef FEAT_GUI
-	if (gui.in_use)
-	{
-	    /*
-	     * GUI special key codes are all of the form [CSI xx].
-	     */
-	    if (*tp == CSI)	    /* Special key from GUI */
-	    {
-		if (len < 3)
-		    return -1;	    /* Shouldn't happen */
-		slen = 3;
-		key_name[0] = tp[1];
-		key_name[1] = tp[2];
-	    }
-	}
-	else
+        if (gui.in_use)
+        {
+            /*
+             * GUI special key codes are all of the form [CSI xx].
+             */
+            if (*tp == CSI)	    /* Special key from GUI */
+            {
+                if (len < 3)
+                    return -1;	    /* Shouldn't happen */
+                slen = 3;
+                key_name[0] = tp[1];
+                key_name[1] = tp[2];
+            }
+        }
+        else
 #endif /* FEAT_GUI */
-	{
-	    for (idx = 0; idx < tc_len; ++idx)
-	    {
-		/*
-		 * Ignore the entry if we are not at the start of
-		 * typebuf.tb_buf[]
-		 * and there are not enough characters to make a match.
-		 * But only when the 'K' flag is in 'cpoptions'.
-		 */
-		slen = termcodes[idx].len;
-		if (cpo_koffset && offset && len < slen)
-		    continue;
-		if (STRNCMP(termcodes[idx].code, tp,
-				     (size_t)(slen > len ? len : slen)) == 0)
-		{
-		    if (len < slen)		/* got a partial sequence */
-			return -1;		/* need to get more chars */
-
-		    /*
-		     * When found a keypad key, check if there is another key
-		     * that matches and use that one.  This makes <Home> to be
-		     * found instead of <kHome> when they produce the same
-		     * key code.
-		     */
-		    if (termcodes[idx].name[0] == 'K'
-				       && VIM_ISDIGIT(termcodes[idx].name[1]))
-		    {
-			for (j = idx + 1; j < tc_len; ++j)
-			    if (termcodes[j].len == slen &&
-				    STRNCMP(termcodes[idx].code,
-					    termcodes[j].code, slen) == 0)
-			    {
-				idx = j;
-				break;
-			    }
-		    }
-
-		    key_name[0] = termcodes[idx].name[0];
-		    key_name[1] = termcodes[idx].name[1];
-		    break;
-		}
-
-		/*
-		 * Check for code with modifier, like xterm uses:
-		 * <Esc>[123;*X  (modslen == slen - 3)
-		 * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).
-		 * When there is a modifier the * matches a number.
-		 * When there is no modifier the ;* or * is omitted.
-		 */
-		if (termcodes[idx].modlen > 0)
-		{
-		    modslen = termcodes[idx].modlen;
-		    if (cpo_koffset && offset && len < modslen)
-			continue;
-		    if (STRNCMP(termcodes[idx].code, tp,
-				(size_t)(modslen > len ? len : modslen)) == 0)
-		    {
-			int	    n;
-
-			if (len <= modslen)	/* got a partial sequence */
-			    return -1;		/* need to get more chars */
-
-			if (tp[modslen] == termcodes[idx].code[slen - 1])
-			    slen = modslen + 1;	/* no modifiers */
-			else if (tp[modslen] != ';' && modslen == slen - 3)
-			    continue;	/* no match */
-			else
-			{
-			    /* Skip over the digits, the final char must
-			     * follow. */
-			    for (j = slen - 2; j < len && isdigit(tp[j]); ++j)
-				;
-			    ++j;
-			    if (len < j)	/* got a partial sequence */
-				return -1;	/* need to get more chars */
-			    if (tp[j - 1] != termcodes[idx].code[slen - 1])
-				continue;	/* no match */
-
-			    /* Match!  Convert modifier bits. */
-			    n = atoi((char *)tp + slen - 2) - 1;
-			    if (n & 1)
-				modifiers |= MOD_MASK_SHIFT;
-			    if (n & 2)
-				modifiers |= MOD_MASK_ALT;
-			    if (n & 4)
-				modifiers |= MOD_MASK_CTRL;
-			    if (n & 8)
-				modifiers |= MOD_MASK_META;
-
-			    slen = j;
-			}
-			key_name[0] = termcodes[idx].name[0];
-			key_name[1] = termcodes[idx].name[1];
-			break;
-		    }
-		}
-	    }
-	}
+        {
+            for (idx = 0; idx < tc_len; ++idx)
+            {
+                /*
+                 * Ignore the entry if we are not at the start of
+                 * typebuf.tb_buf[]
+                 * and there are not enough characters to make a match.
+                 * But only when the 'K' flag is in 'cpoptions'.
+                 */
+                slen = termcodes[idx].len;
+                if (cpo_koffset && offset && len < slen)
+                    continue;
+                if (STRNCMP(termcodes[idx].code, tp,
+                            (size_t)(slen > len ? len : slen)) == 0)
+                {
+                    if (len < slen)		/* got a partial sequence */
+                        return -1;		/* need to get more chars */
+
+                    /*
+                     * When found a keypad key, check if there is another key
+                     * that matches and use that one.  This makes <Home> to be
+                     * found instead of <kHome> when they produce the same
+                     * key code.
+                     */
+                    if (termcodes[idx].name[0] == 'K'
+                            && VIM_ISDIGIT(termcodes[idx].name[1]))
+                    {
+                        for (j = idx + 1; j < tc_len; ++j)
+                            if (termcodes[j].len == slen &&
+                                    STRNCMP(termcodes[idx].code,
+                                        termcodes[j].code, slen) == 0)
+                            {
+                                idx = j;
+                                break;
+                            }
+                    }
+
+                    key_name[0] = termcodes[idx].name[0];
+                    key_name[1] = termcodes[idx].name[1];
+                    break;
+                }
+
+                /*
+                 * Check for code with modifier, like xterm uses:
+                 * <Esc>[123;*X  (modslen == slen - 3)
+                 * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).
+                 * When there is a modifier the * matches a number.
+                 * When there is no modifier the ;* or * is omitted.
+                 */
+                if (termcodes[idx].modlen > 0)
+                {
+                    modslen = termcodes[idx].modlen;
+                    if (cpo_koffset && offset && len < modslen)
+                        continue;
+                    if (STRNCMP(termcodes[idx].code, tp,
+                                (size_t)(modslen > len ? len : modslen)) == 0)
+                    {
+                        int	    n;
+
+                        if (len <= modslen)	/* got a partial sequence */
+                            return -1;		/* need to get more chars */
+
+                        if (tp[modslen] == termcodes[idx].code[slen - 1])
+                            slen = modslen + 1;	/* no modifiers */
+                        else if (tp[modslen] != ';' && modslen == slen - 3)
+                            continue;	/* no match */
+                        else
+                        {
+                            /* Skip over the digits, the final char must
+                             * follow. */
+                            for (j = slen - 2; j < len && isdigit(tp[j]); ++j)
+                                ;
+                            ++j;
+                            if (len < j)	/* got a partial sequence */
+                                return -1;	/* need to get more chars */
+                            if (tp[j - 1] != termcodes[idx].code[slen - 1])
+                                continue;	/* no match */
+
+                            /* Match!  Convert modifier bits. */
+                            n = atoi((char *)tp + slen - 2) - 1;
+                            if (n & 1)
+                                modifiers |= MOD_MASK_SHIFT;
+                            if (n & 2)
+                                modifiers |= MOD_MASK_ALT;
+                            if (n & 4)
+                                modifiers |= MOD_MASK_CTRL;
+                            if (n & 8)
+                                modifiers |= MOD_MASK_META;
+
+                            slen = j;
+                        }
+                        key_name[0] = termcodes[idx].name[0];
+                        key_name[1] = termcodes[idx].name[1];
+                        break;
+                    }
+                }
+            }
+        }
 
 #ifdef FEAT_TERMRESPONSE
-	if (key_name[0] == NUL
-	    /* Mouse codes of DEC, pterm, and URXVT start with <ESC>[.  When
-	     * detecting the start of these mouse codes they might as well be
-	     * another key code or terminal response. */
+        if (key_name[0] == NUL
+                /* Mouse codes of DEC, pterm, and URXVT start with <ESC>[.  When
+                 * detecting the start of these mouse codes they might as well be
+                 * another key code or terminal response. */
 # ifdef FEAT_MOUSE_DEC
-	    || key_name[0] == KS_DEC_MOUSE
+                || key_name[0] == KS_DEC_MOUSE
 # endif
 # ifdef FEAT_MOUSE_PTERM
-	    || key_name[0] == KS_PTERM_MOUSE
+                || key_name[0] == KS_PTERM_MOUSE
 # endif
 # ifdef FEAT_MOUSE_URXVT
-	    || key_name[0] == KS_URXVT_MOUSE
+                || key_name[0] == KS_URXVT_MOUSE
 # endif
-	   )
-	{
-	    /* Check for some responses from the terminal starting with
-	     * "<Esc>[" or CSI:
-	     *
-	     * - Xterm version string: <Esc>[>{x};{vers};{y}c
-	     *   Also eat other possible responses to t_RV, rxvt returns
-	     *   "<Esc>[?1;2c". Also accept CSI instead of <Esc>[.
-	     *   mrxvt has been reported to have "+" in the version. Assume
-	     *   the escape sequence ends with a letter or one of "{|}~".
-	     *
-	     * - Cursor position report: <Esc>[{row};{col}R
-	     *   The final byte must be 'R'. It is used for checking the
-	     *   ambiguous-width character state.
-	     */
-	    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;
-
-	    if ((*T_CRV != NUL || *T_U7 != NUL)
-			&& ((tp[0] == ESC && len >= 3 && tp[1] == '[')
-			    || (tp[0] == CSI && len >= 2))
-			&& (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))
-	    {
+           )
+        {
+            /* Check for some responses from the terminal starting with
+             * "<Esc>[" or CSI:
+             *
+             * - Xterm version string: <Esc>[>{x};{vers};{y}c
+             *   Also eat other possible responses to t_RV, rxvt returns
+             *   "<Esc>[?1;2c". Also accept CSI instead of <Esc>[.
+             *   mrxvt has been reported to have "+" in the version. Assume
+             *   the escape sequence ends with a letter or one of "{|}~".
+             *
+             * - Cursor position report: <Esc>[{row};{col}R
+             *   The final byte must be 'R'. It is used for checking the
+             *   ambiguous-width character state.
+             */
+            char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;
+
+            if ((*T_CRV != NUL || *T_U7 != NUL)
+                    && ((tp[0] == ESC && len >= 3 && tp[1] == '[')
+                        || (tp[0] == CSI && len >= 2))
+                    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))
+            {
 #ifdef FEAT_MBYTE
-		int col;
-		int row_char = NUL;
-#endif
-		j = 0;
-		extra = 0;
-		for (i = 2 + (tp[0] != CSI); i < len
-				&& !(tp[i] >= '{' && tp[i] <= '~')
-				&& !ASCII_ISALPHA(tp[i]); ++i)
-		    if (tp[i] == ';' && ++j == 1)
-		    {
-			extra = i + 1;
+                int col;
+                int row_char = NUL;
+#endif
+                j = 0;
+                extra = 0;
+                for (i = 2 + (tp[0] != CSI); i < len
+                        && !(tp[i] >= '{' && tp[i] <= '~')
+                        && !ASCII_ISALPHA(tp[i]); ++i)
+                    if (tp[i] == ';' && ++j == 1)
+                    {
+                        extra = i + 1;
 #ifdef FEAT_MBYTE
-			row_char = tp[i - 1];
-#endif
-		    }
-		if (i == len)
-		{
-		    LOG_TR("Not enough characters for CRV");
-		    return -1;
-		}
+                        row_char = tp[i - 1];
+#endif
+                    }
+                if (i == len)
+                {
+                    LOG_TR("Not enough characters for CRV");
+                    return -1;
+                }
 #ifdef FEAT_MBYTE
-		if (extra > 0)
-		    col = atoi((char *)tp + extra);
-		else
-		    col = 0;
-
-		/* Eat it when it has 2 arguments and ends in 'R'. Also when
-		 * u7_status is not "sent", it may be from a previous Vim that
-		 * just exited.  But not for <S-F3>, it sends something
-		 * similar, check for row and column to make sense. */
-		if (j == 1 && tp[i] == 'R')
-		{
-		    if (row_char == '2' && col >= 2)
-		    {
-			char *aw = NULL;
-
-			LOG_TR("Received U7 status");
-			u7_status = U7_GOT;
+                if (extra > 0)
+                    col = atoi((char *)tp + extra);
+                else
+                    col = 0;
+
+                /* Eat it when it has 2 arguments and ends in 'R'. Also when
+                 * u7_status is not "sent", it may be from a previous Vim that
+                 * just exited.  But not for <S-F3>, it sends something
+                 * similar, check for row and column to make sense. */
+                if (j == 1 && tp[i] == 'R')
+                {
+                    if (row_char == '2' && col >= 2)
+                    {
+                        char *aw = NULL;
+
+                        LOG_TR("Received U7 status");
+                        u7_status = U7_GOT;
 # ifdef FEAT_AUTOCMD
-			did_cursorhold = TRUE;
+                        did_cursorhold = TRUE;
 # endif
-			if (col == 2)
-			    aw = "single";
-			else if (col == 3)
-			    aw = "double";
-			if (aw != NULL && STRCMP(aw, p_ambw) != 0)
-			{
-			    /* Setting the option causes a screen redraw. Do
-			     * that right away if possible, keeping any
-			     * messages. */
-			    set_option_value((char_u *)"ambw", 0L,
-					     (char_u *)aw, 0);
+                        if (col == 2)
+                            aw = "single";
+                        else if (col == 3)
+                            aw = "double";
+                        if (aw != NULL && STRCMP(aw, p_ambw) != 0)
+                        {
+                            /* Setting the option causes a screen redraw. Do
+                             * that right away if possible, keeping any
+                             * messages. */
+                            set_option_value((char_u *)"ambw", 0L,
+                                    (char_u *)aw, 0);
 # ifdef DEBUG_TERMRESPONSE
-			    {
-				char buf[100];
-				int  r = redraw_asap(CLEAR);
-
-				sprintf(buf,
-					"set 'ambiwidth', redraw_asap(): %d",
-					r);
-				log_tr(buf);
-			    }
+                            {
+                                char buf[100];
+                                int  r = redraw_asap(CLEAR);
+
+                                sprintf(buf,
+                                        "set 'ambiwidth', redraw_asap(): %d",
+                                        r);
+                                log_tr(buf);
+                            }
 # else
-			    redraw_asap(CLEAR);
+                            redraw_asap(CLEAR);
 # endif
-			}
-		    }
-		    key_name[0] = (int)KS_EXTRA;
-		    key_name[1] = (int)KE_IGNORE;
-		    slen = i + 1;
-		}
-		else
-#endif
-		/* eat it when at least one digit and ending in 'c' */
-		if (*T_CRV != NUL && i > 2 + (tp[0] != CSI) && tp[i] == 'c')
-		{
-		    LOG_TR("Received CRV");
-		    crv_status = CRV_GOT;
+                        }
+                    }
+                    key_name[0] = (int)KS_EXTRA;
+                    key_name[1] = (int)KE_IGNORE;
+                    slen = i + 1;
+                }
+                else
+#endif
+                    /* eat it when at least one digit and ending in 'c' */
+                    if (*T_CRV != NUL && i > 2 + (tp[0] != CSI) && tp[i] == 'c')
+                    {
+                        LOG_TR("Received CRV");
+                        crv_status = CRV_GOT;
 # ifdef FEAT_AUTOCMD
-		    did_cursorhold = TRUE;
+                        did_cursorhold = TRUE;
 # endif
 
-		    /* If this code starts with CSI, you can bet that the
-		     * terminal uses 8-bit codes. */
-		    if (tp[0] == CSI)
-			switch_to_8bit();
-
-		    /* rxvt sends its version number: "20703" is 2.7.3.
-		     * Ignore it for when the user has set 'term' to xterm,
-		     * even though it's an rxvt. */
-		    if (extra > 0)
-			extra = atoi((char *)tp + extra);
-		    if (extra > 20000)
-			extra = 0;
-
-		    if (tp[1 + (tp[0] != CSI)] == '>' && j == 2)
-		    {
-			/* Only set 'ttymouse' automatically if it was not set
-			 * by the user already. */
-			if (!option_was_set((char_u *)"ttym"))
-			{
+                        /* If this code starts with CSI, you can bet that the
+                         * terminal uses 8-bit codes. */
+                        if (tp[0] == CSI)
+                            switch_to_8bit();
+
+                        /* rxvt sends its version number: "20703" is 2.7.3.
+                         * Ignore it for when the user has set 'term' to xterm,
+                         * even though it's an rxvt. */
+                        if (extra > 0)
+                            extra = atoi((char *)tp + extra);
+                        if (extra > 20000)
+                            extra = 0;
+
+                        if (tp[1 + (tp[0] != CSI)] == '>' && j == 2)
+                        {
+                            /* Only set 'ttymouse' automatically if it was not set
+                             * by the user already. */
+                            if (!option_was_set((char_u *)"ttym"))
+                            {
 # ifdef TTYM_SGR
-			    if (extra >= 277)
-				set_option_value((char_u *)"ttym", 0L,
-							  (char_u *)"sgr", 0);
-			    else
+                                if (extra >= 277)
+                                    set_option_value((char_u *)"ttym", 0L,
+                                            (char_u *)"sgr", 0);
+                                else
 # endif
-			    /* if xterm version >= 95 use mouse dragging */
-			    if (extra >= 95)
-				set_option_value((char_u *)"ttym", 0L,
-						       (char_u *)"xterm2", 0);
-			}
-
-			/* if xterm version >= 141 try to get termcap codes */
-			if (extra >= 141)
-			{
-			    LOG_TR("Enable checking for XT codes");
-			    check_for_codes = TRUE;
-			    need_gather = TRUE;
-			    req_codes_from_term();
-			}
-		    }
+                                    /* if xterm version >= 95 use mouse dragging */
+                                    if (extra >= 95)
+                                        set_option_value((char_u *)"ttym", 0L,
+                                                (char_u *)"xterm2", 0);
+                            }
+
+                            /* if xterm version >= 141 try to get termcap codes */
+                            if (extra >= 141)
+                            {
+                                LOG_TR("Enable checking for XT codes");
+                                check_for_codes = TRUE;
+                                need_gather = TRUE;
+                                req_codes_from_term();
+                            }
+                        }
 # ifdef FEAT_EVAL
-		    set_vim_var_string(VV_TERMRESPONSE, tp, i + 1);
+                        set_vim_var_string(VV_TERMRESPONSE, tp, i + 1);
 # endif
 # ifdef FEAT_AUTOCMD
-		    apply_autocmds(EVENT_TERMRESPONSE,
-						   NULL, NULL, FALSE, curbuf);
+                        apply_autocmds(EVENT_TERMRESPONSE,
+                                NULL, NULL, FALSE, curbuf);
 # endif
-		    key_name[0] = (int)KS_EXTRA;
-		    key_name[1] = (int)KE_IGNORE;
-		    slen = i + 1;
-		}
-	    }
-
-	    /* Check for background color response from the terminal:
-	     *
-	     *       {lead}11;rgb:{rrrr}/{gggg}/{bbbb}{tail}
-	     *
-	     * {lead} can be <Esc>] or OSC
-	     * {tail} can be '\007', <Esc>\ or STERM.
-	     *
-	     * Consume any code that starts with "{lead}11;", it's also
-	     * possible that "rgba" is following.
-	     */
-	    else if (*T_RBG != NUL
-			&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')
-			    || tp[0] == OSC))
-	    {
-		j = 1 + (tp[0] == ESC);
-		if (len >= j + 3 && (argp[0] != '1'
-					 || argp[1] != '1' || argp[2] != ';'))
-		  i = 0; /* no match */
-		else
-		  for (i = j; i < len; ++i)
-		    if (tp[i] == '\007' || (tp[0] == OSC ? tp[i] == STERM
-			: (tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\')))
-		    {
-			if (i - j >= 21 && STRNCMP(tp + j + 3, "rgb:", 4) == 0
-			    && tp[j + 11] == '/' && tp[j + 16] == '/'
-			    && !option_was_set((char_u *)"bg"))
-			{/* TODO: don't set option when already the right value */
-			    LOG_TR("Received RBG");
-			    rbg_status = RBG_GOT;
-			    set_option_value((char_u *)"bg", 0L, (char_u *)(
-				    (3 * '6' < tp[j+7] + tp[j+12] + tp[j+17])
-				    ? "light" : "dark"), 0);
-			    reset_option_was_set((char_u *)"bg");
-			    redraw_asap(CLEAR);
-			}
-
-			/* got finished code: consume it */
-			key_name[0] = (int)KS_EXTRA;
-			key_name[1] = (int)KE_IGNORE;
-			slen = i + 1 + (tp[i] == ESC);
-			break;
-		    }
-		if (i == len)
-		{
-		    LOG_TR("not enough characters for RB");
-		    return -1;
-		}
-	    }
-
-	    /* Check for key code response from xterm:
-	     *
-	     * {lead}{flag}+r<hex bytes><{tail}
-	     *
-	     * {lead} can be <Esc>P or DCS
-	     * {flag} can be '0' or '1'
-	     * {tail} can be Esc>\ or STERM
-	     *
-	     * Consume any code that starts with "{lead}.+r".
-	     */
-	    else if (check_for_codes
-		    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')
-			|| tp[0] == DCS))
-	    {
-		j = 1 + (tp[0] == ESC);
-		if (len >= j + 3 && (argp[1] != '+' || argp[2] != 'r'))
-		  i = 0; /* no match */
-		else
-		  for (i = j; i < len; ++i)
-		    if ((tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\')
-			    || tp[i] == STERM)
-		    {
-			if (i - j >= 3)
-			    got_code_from_term(tp + j, i);
-			key_name[0] = (int)KS_EXTRA;
-			key_name[1] = (int)KE_IGNORE;
-			slen = i + 1 + (tp[i] == ESC);
-			break;
-		    }
-
-		if (i == len)
-		{
-		    /* These codes arrive many together, each code can be
-		     * truncated at any point. */
-		    LOG_TR("not enough characters for XT");
-		    return -1;
-		}
-	    }
-	}
-#endif
-
-	if (key_name[0] == NUL)
-	    continue;	    /* No match at this position, try next one */
-
-	/* We only get here when we have a complete termcode match */
+                        key_name[0] = (int)KS_EXTRA;
+                        key_name[1] = (int)KE_IGNORE;
+                        slen = i + 1;
+                    }
+            }
+
+            /* Check for background color response from the terminal:
+             *
+             *       {lead}11;rgb:{rrrr}/{gggg}/{bbbb}{tail}
+             *
+             * {lead} can be <Esc>] or OSC
+             * {tail} can be '\007', <Esc>\ or STERM.
+             *
+             * Consume any code that starts with "{lead}11;", it's also
+             * possible that "rgba" is following.
+             */
+            else if (*T_RBG != NUL
+                    && ((tp[0] == ESC && len >= 2 && tp[1] == ']')
+                        || tp[0] == OSC))
+            {
+                j = 1 + (tp[0] == ESC);
+                if (len >= j + 3 && (argp[0] != '1'
+                            || argp[1] != '1' || argp[2] != ';'))
+                    i = 0; /* no match */
+                else
+                    for (i = j; i < len; ++i)
+                        if (tp[i] == '\007' || (tp[0] == OSC ? tp[i] == STERM
+                                    : (tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\')))
+                        {
+                            if (i - j >= 21 && STRNCMP(tp + j + 3, "rgb:", 4) == 0
+                                    && tp[j + 11] == '/' && tp[j + 16] == '/'
+                                    && !option_was_set((char_u *)"bg"))
+                            {/* TODO: don't set option when already the right value */
+                                LOG_TR("Received RBG");
+                                rbg_status = RBG_GOT;
+                                set_option_value((char_u *)"bg", 0L, (char_u *)(
+                                            (3 * '6' < tp[j+7] + tp[j+12] + tp[j+17])
+                                            ? "light" : "dark"), 0);
+                                reset_option_was_set((char_u *)"bg");
+                                redraw_asap(CLEAR);
+                            }
+
+                            /* got finished code: consume it */
+                            key_name[0] = (int)KS_EXTRA;
+                            key_name[1] = (int)KE_IGNORE;
+                            slen = i + 1 + (tp[i] == ESC);
+                            break;
+                        }
+                if (i == len)
+                {
+                    LOG_TR("not enough characters for RB");
+                    return -1;
+                }
+            }
+
+            /* Check for key code response from xterm:
+             *
+             * {lead}{flag}+r<hex bytes><{tail}
+             *
+             * {lead} can be <Esc>P or DCS
+             * {flag} can be '0' or '1'
+             * {tail} can be Esc>\ or STERM
+             *
+             * Consume any code that starts with "{lead}.+r".
+             */
+            else if (check_for_codes
+                    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')
+                        || tp[0] == DCS))
+            {
+                j = 1 + (tp[0] == ESC);
+                if (len >= j + 3 && (argp[1] != '+' || argp[2] != 'r'))
+                    i = 0; /* no match */
+                else
+                    for (i = j; i < len; ++i)
+                        if ((tp[i] == ESC && i + 1 < len && tp[i + 1] == '\\')
+                                || tp[i] == STERM)
+                        {
+                            if (i - j >= 3)
+                                got_code_from_term(tp + j, i);
+                            key_name[0] = (int)KS_EXTRA;
+                            key_name[1] = (int)KE_IGNORE;
+                            slen = i + 1 + (tp[i] == ESC);
+                            break;
+                        }
+
+                if (i == len)
+                {
+                    /* These codes arrive many together, each code can be
+                     * truncated at any point. */
+                    LOG_TR("not enough characters for XT");
+                    return -1;
+                }
+            }
+        }
+#endif
+
+        if (key_name[0] == NUL)
+            continue;	    /* No match at this position, try next one */
+
+        /* We only get here when we have a complete termcode match */
 
 #ifdef FEAT_MOUSE
 # ifdef FEAT_GUI
-	/*
-	 * Only in the GUI: Fetch the pointer coordinates of the scroll event
-	 * so that we know which window to scroll later.
-	 */
-	if (gui.in_use
-		&& key_name[0] == (int)KS_EXTRA
-		&& (key_name[1] == (int)KE_X1MOUSE
-		    || key_name[1] == (int)KE_X2MOUSE
-		    || key_name[1] == (int)KE_MOUSELEFT
-		    || key_name[1] == (int)KE_MOUSERIGHT
-		    || key_name[1] == (int)KE_MOUSEDOWN
-		    || key_name[1] == (int)KE_MOUSEUP))
-	{
-	    num_bytes = get_bytes_from_buf(tp + slen, bytes, 4);
-	    if (num_bytes == -1)	/* not enough coordinates */
-		return -1;
-	    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;
-	    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;
-	    slen += num_bytes;
-	}
-	else
+        /*
+         * Only in the GUI: Fetch the pointer coordinates of the scroll event
+         * so that we know which window to scroll later.
+         */
+        if (gui.in_use
+                && key_name[0] == (int)KS_EXTRA
+                && (key_name[1] == (int)KE_X1MOUSE
+                    || key_name[1] == (int)KE_X2MOUSE
+                    || key_name[1] == (int)KE_MOUSELEFT
+                    || key_name[1] == (int)KE_MOUSERIGHT
+                    || key_name[1] == (int)KE_MOUSEDOWN
+                    || key_name[1] == (int)KE_MOUSEUP))
+        {
+            num_bytes = get_bytes_from_buf(tp + slen, bytes, 4);
+            if (num_bytes == -1)	/* not enough coordinates */
+                return -1;
+            mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;
+            mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;
+            slen += num_bytes;
+        }
+        else
 # endif
-	/*
-	 * If it is a mouse click, get the coordinates.
-	 */
-	if (key_name[0] == KS_MOUSE
+            /*
+             * If it is a mouse click, get the coordinates.
+             */
+            if (key_name[0] == KS_MOUSE
 # ifdef FEAT_MOUSE_JSB
-		|| key_name[0] == KS_JSBTERM_MOUSE
+                    || key_name[0] == KS_JSBTERM_MOUSE
 # endif
 # ifdef FEAT_MOUSE_NET
-		|| key_name[0] == KS_NETTERM_MOUSE
+                    || key_name[0] == KS_NETTERM_MOUSE
 # endif
 # ifdef FEAT_MOUSE_DEC
-		|| key_name[0] == KS_DEC_MOUSE
+                    || key_name[0] == KS_DEC_MOUSE
 # endif
 # ifdef FEAT_MOUSE_PTERM
-		|| key_name[0] == KS_PTERM_MOUSE
+                    || key_name[0] == KS_PTERM_MOUSE
 # endif
 # ifdef FEAT_MOUSE_URXVT
-		|| key_name[0] == KS_URXVT_MOUSE
+                    || key_name[0] == KS_URXVT_MOUSE
 # endif
 # ifdef FEAT_MOUSE_SGR
-		|| key_name[0] == KS_SGR_MOUSE
+                    || key_name[0] == KS_SGR_MOUSE
 # endif
-		)
-	{
-	    is_click = is_drag = FALSE;
+               )
+            {
+                is_click = is_drag = FALSE;
 
 # if !defined(UNIX) || defined(FEAT_MOUSE_XTERM) || defined(FEAT_GUI) \
-	    || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)
-	    if (key_name[0] == (int)KS_MOUSE)
-	    {
-		/*
-		 * For xterm we get "<t_mouse>scr", where
-		 *  s == encoded button state:
-		 *	   0x20 = left button down
-		 *	   0x21 = middle button down
-		 *	   0x22 = right button down
-		 *	   0x23 = any button release
-		 *	   0x60 = button 4 down (scroll wheel down)
-		 *	   0x61 = button 5 down (scroll wheel up)
-		 *	add 0x04 for SHIFT
-		 *	add 0x08 for ALT
-		 *	add 0x10 for CTRL
-		 *	add 0x20 for mouse drag (0x40 is drag with left button)
-		 *  c == column + ' ' + 1 == column + 33
-		 *  r == row + ' ' + 1 == row + 33
-		 *
-		 * The coordinates are passed on through global variables.
-		 * Ugly, but this avoids trouble with mouse clicks at an
-		 * unexpected moment and allows for mapping them.
-		 */
-		for (;;)
-		{
+                || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)
+                if (key_name[0] == (int)KS_MOUSE)
+                {
+                    /*
+                     * For xterm we get "<t_mouse>scr", where
+                     *  s == encoded button state:
+                     *	   0x20 = left button down
+                     *	   0x21 = middle button down
+                     *	   0x22 = right button down
+                     *	   0x23 = any button release
+                     *	   0x60 = button 4 down (scroll wheel down)
+                     *	   0x61 = button 5 down (scroll wheel up)
+                     *	add 0x04 for SHIFT
+                     *	add 0x08 for ALT
+                     *	add 0x10 for CTRL
+                     *	add 0x20 for mouse drag (0x40 is drag with left button)
+                     *  c == column + ' ' + 1 == column + 33
+                     *  r == row + ' ' + 1 == row + 33
+                     *
+                     * The coordinates are passed on through global variables.
+                     * Ugly, but this avoids trouble with mouse clicks at an
+                     * unexpected moment and allows for mapping them.
+                     */
+                    for (;;)
+                    {
 #ifdef FEAT_GUI
-		    if (gui.in_use)
-		    {
-			/* GUI uses more bits for columns > 223 */
-			num_bytes = get_bytes_from_buf(tp + slen, bytes, 5);
-			if (num_bytes == -1)	/* not enough coordinates */
-			    return -1;
-			mouse_code = bytes[0];
-			mouse_col = 128 * (bytes[1] - ' ' - 1)
-							 + bytes[2] - ' ' - 1;
-			mouse_row = 128 * (bytes[3] - ' ' - 1)
-							 + bytes[4] - ' ' - 1;
-		    }
-		    else
-#endif
-		    {
-			num_bytes = get_bytes_from_buf(tp + slen, bytes, 3);
-			if (num_bytes == -1)	/* not enough coordinates */
-			    return -1;
-			mouse_code = bytes[0];
-			mouse_col = bytes[1] - ' ' - 1;
-			mouse_row = bytes[2] - ' ' - 1;
-		    }
-		    slen += num_bytes;
-
-		    /* If the following bytes is also a mouse code and it has
-		     * the same code, dump this one and get the next.  This
-		     * makes dragging a whole lot faster. */
+                        if (gui.in_use)
+                        {
+                            /* GUI uses more bits for columns > 223 */
+                            num_bytes = get_bytes_from_buf(tp + slen, bytes, 5);
+                            if (num_bytes == -1)	/* not enough coordinates */
+                                return -1;
+                            mouse_code = bytes[0];
+                            mouse_col = 128 * (bytes[1] - ' ' - 1)
+                                + bytes[2] - ' ' - 1;
+                            mouse_row = 128 * (bytes[3] - ' ' - 1)
+                                + bytes[4] - ' ' - 1;
+                        }
+                        else
+#endif
+                        {
+                            num_bytes = get_bytes_from_buf(tp + slen, bytes, 3);
+                            if (num_bytes == -1)	/* not enough coordinates */
+                                return -1;
+                            mouse_code = bytes[0];
+                            mouse_col = bytes[1] - ' ' - 1;
+                            mouse_row = bytes[2] - ' ' - 1;
+                        }
+                        slen += num_bytes;
+
+                        /* If the following bytes is also a mouse code and it has
+                         * the same code, dump this one and get the next.  This
+                         * makes dragging a whole lot faster. */
 #ifdef FEAT_GUI
-		    if (gui.in_use)
-			j = 3;
-		    else
-#endif
-			j = termcodes[idx].len;
-		    if (STRNCMP(tp, tp + slen, (size_t)j) == 0
-			    && tp[slen + j] == mouse_code
-			    && tp[slen + j + 1] != NUL
-			    && tp[slen + j + 2] != NUL
+                        if (gui.in_use)
+                            j = 3;
+                        else
+#endif
+                            j = termcodes[idx].len;
+                        if (STRNCMP(tp, tp + slen, (size_t)j) == 0
+                                && tp[slen + j] == mouse_code
+                                && tp[slen + j + 1] != NUL
+                                && tp[slen + j + 2] != NUL
 #ifdef FEAT_GUI
-			    && (!gui.in_use
-				|| (tp[slen + j + 3] != NUL
-					&& tp[slen + j + 4] != NUL))
+                                && (!gui.in_use
+                                    || (tp[slen + j + 3] != NUL
+                                        && tp[slen + j + 4] != NUL))
 #endif
-			    )
-			slen += j;
-		    else
-			break;
-		}
-	    }
+                           )
+                            slen += j;
+                        else
+                            break;
+                    }
+                }
+
+                lp("/tmp/log1", "\tmouse_code = %d\n", mouse_code);
 
 # if defined(FEAT_MOUSE_URXVT) || defined(FEAT_MOUSE_SGR)
-	    if (key_name[0] == KS_URXVT_MOUSE
-		|| key_name[0] == KS_SGR_MOUSE)
-	    {
-		for (;;)
-		{
-		    /* URXVT 1015 mouse reporting mode:
-		     * Almost identical to xterm mouse mode, except the values
-		     * are decimal instead of bytes.
-		     *
-		     * \033[%d;%d;%dM
-		     *		  ^-- row
-		     *	       ^----- column
-		     *	    ^-------- code
-		     *
-		     * SGR 1006 mouse reporting mode:
-		     * Almost identical to xterm mouse mode, except the values
-		     * are decimal instead of bytes.
-		     *
-		     * \033[<%d;%d;%dM
-		     *		   ^-- row
-		     *	        ^----- column
-		     *	     ^-------- code
-		     *
-		     * \033[<%d;%d;%dm        : mouse release event
-		     *		   ^-- row
-		     *	        ^----- column
-		     *	     ^-------- code
-		     */
-		    p = tp + slen;
-
-		    mouse_code = getdigits(&p);
-		    if (*p++ != ';')
-			return -1;
-
-		    /* when mouse reporting is SGR, add 32 to mouse code */
-		    if (key_name[0] == KS_SGR_MOUSE)
-			mouse_code += 32;
-
-		    mouse_col = getdigits(&p) - 1;
-		    if (*p++ != ';')
-			return -1;
-
-		    mouse_row = getdigits(&p) - 1;
-		    if (key_name[0] == KS_SGR_MOUSE && *p == 'm')
-			mouse_code |= MOUSE_RELEASE;
-		    else if (*p != 'M')
-			return -1;
-		    p++;
-
-		    slen += (int)(p - (tp + slen));
-
-		    /* skip this one if next one has same code (like xterm
-		     * case) */
-		    j = termcodes[idx].len;
-		    if (STRNCMP(tp, tp + slen, (size_t)j) == 0)
-		    {
-			int slen2;
-			int cmd_complete = 0;
-
-			/* check if the command is complete by looking for the
-			 * 'M' */
-			for (slen2 = slen; slen2 < len; slen2++)
-			{
-			    if (tp[slen2] == 'M'
-				    || (key_name[0] == KS_SGR_MOUSE
-							 && tp[slen2] == 'm'))
-			    {
-				cmd_complete = 1;
-				break;
-			    }
-			}
-			p += j;
-			if (cmd_complete && getdigits(&p) == mouse_code)
-			{
-			    slen += j; /* skip the \033[ */
-			    continue;
-			}
-		    }
-		    break;
-		}
-	    }
+                if (key_name[0] == KS_URXVT_MOUSE
+                        || key_name[0] == KS_SGR_MOUSE)
+                {
+                    for (;;)
+                    {
+                        /* URXVT 1015 mouse reporting mode:
+                         * Almost identical to xterm mouse mode, except the values
+                         * are decimal instead of bytes.
+                         *
+                         * \033[%d;%d;%dM
+                         *		  ^-- row
+                         *	       ^----- column
+                         *	    ^-------- code
+                         *
+                         * SGR 1006 mouse reporting mode:
+                         * Almost identical to xterm mouse mode, except the values
+                         * are decimal instead of bytes.
+                         *
+                         * \033[<%d;%d;%dM
+                         *		   ^-- row
+                         *	        ^----- column
+                         *	     ^-------- code
+                         *
+                         * \033[<%d;%d;%dm        : mouse release event
+                         *		   ^-- row
+                         *	        ^----- column
+                         *	     ^-------- code
+                         */
+                        p = tp + slen;
+
+                        mouse_code = getdigits(&p);
+                        if (*p++ != ';')
+                            return -1;
+
+                        /* when mouse reporting is SGR, add 32 to mouse code */
+                        if (key_name[0] == KS_SGR_MOUSE)
+                            mouse_code += 32;
+
+                        mouse_col = getdigits(&p) - 1;
+                        if (*p++ != ';')
+                            return -1;
+
+                        mouse_row = getdigits(&p) - 1;
+                        if (key_name[0] == KS_SGR_MOUSE && *p == 'm')
+                            mouse_code |= MOUSE_RELEASE;
+                        else if (*p != 'M')
+                            return -1;
+                        p++;
+
+                        slen += (int)(p - (tp + slen));
+
+                        /* skip this one if next one has same code (like xterm
+                         * case) */
+                        j = termcodes[idx].len;
+                        if (STRNCMP(tp, tp + slen, (size_t)j) == 0)
+                        {
+                            int slen2;
+                            int cmd_complete = 0;
+
+                            /* check if the command is complete by looking for the
+                             * 'M' */
+                            for (slen2 = slen; slen2 < len; slen2++)
+                            {
+                                if (tp[slen2] == 'M'
+                                        || (key_name[0] == KS_SGR_MOUSE
+                                            && tp[slen2] == 'm'))
+                                {
+                                    cmd_complete = 1;
+                                    break;
+                                }
+                            }
+                            p += j;
+                            if (cmd_complete && getdigits(&p) == mouse_code)
+                            {
+                                slen += j; /* skip the \033[ */
+                                continue;
+                            }
+                        }
+                        break;
+                    }
+                }
 # endif
 
-	if (key_name[0] == (int)KS_MOUSE
+                if (key_name[0] == (int)KS_MOUSE
 #ifdef FEAT_MOUSE_URXVT
-	    || key_name[0] == (int)KS_URXVT_MOUSE
+                        || key_name[0] == (int)KS_URXVT_MOUSE
 #endif
 #ifdef FEAT_MOUSE_SGR
-	    || key_name[0] == KS_SGR_MOUSE
+                        || key_name[0] == KS_SGR_MOUSE
 #endif
-	    )
-	{
+                   )
+                {
 #  if !defined(MSWIN)
-		/*
-		 * Handle mouse events.
-		 * Recognize the xterm mouse wheel, but not in the GUI, the
-		 * Linux console with GPM and the MS-DOS or Win32 console
-		 * (multi-clicks use >= 0x60).
-		 */
-		if (mouse_code >= MOUSEWHEEL_LOW
+                    /*
+                     * Handle mouse events.
+                     * Recognize the xterm mouse wheel, but not in the GUI, the
+                     * Linux console with GPM and the MS-DOS or Win32 console
+                     * (multi-clicks use >= 0x60).
+                     */
+                    if (mouse_code >= MOUSEWHEEL_LOW
 #   ifdef FEAT_GUI
-			&& !gui.in_use
+                            && !gui.in_use
 #   endif
 #   ifdef FEAT_MOUSE_GPM
-			&& gpm_flag == 0
+                            && gpm_flag == 0
 #   endif
-			)
-		{
-		    /* Keep the mouse_code before it's changed, so that we
-		     * remember that it was a mouse wheel click. */
-		    wheel_code = mouse_code;
-		}
+                       )
+                    {
+                        /* Keep the mouse_code before it's changed, so that we
+                         * remember that it was a mouse wheel click. */
+                        wheel_code = mouse_code;
+                    }
 #   ifdef FEAT_MOUSE_XTERM
-		else if (held_button == MOUSE_RELEASE
+                    else if (held_button == MOUSE_RELEASE
 #    ifdef FEAT_GUI
-			&& !gui.in_use
+                            && !gui.in_use
 #    endif
-			&& (mouse_code == 0x23 || mouse_code == 0x24))
-		{
-		    /* Apparently used by rxvt scroll wheel. */
-		    wheel_code = mouse_code - 0x23 + MOUSEWHEEL_LOW;
-		}
+                            && (mouse_code == 0x23 || mouse_code == 0x24))
+                    {
+                        /* Apparently used by rxvt scroll wheel. */
+                        wheel_code = mouse_code - 0x23 + MOUSEWHEEL_LOW;
+                    }
 #   endif
 
 #   if defined(UNIX) && defined(FEAT_MOUSE_TTY)
-		else if (use_xterm_mouse() > 1)
-		{
-		    if (mouse_code & MOUSE_DRAG_XTERM)
-			mouse_code |= MOUSE_DRAG;
-		}
+                    else if (use_xterm_mouse() > 1)
+                    {
+                        if (mouse_code & MOUSE_DRAG_XTERM)
+                            mouse_code |= MOUSE_DRAG;
+                    }
 #   endif
 #   ifdef FEAT_XCLIPBOARD
-		else if (!(mouse_code & MOUSE_DRAG & ~MOUSE_CLICK_MASK))
-		{
-		    if ((mouse_code & MOUSE_RELEASE) == MOUSE_RELEASE)
-			stop_xterm_trace();
-		    else
-			start_xterm_trace(mouse_code);
-		}
+                    else if (!(mouse_code & MOUSE_DRAG & ~MOUSE_CLICK_MASK))
+                    {
+                        if ((mouse_code & MOUSE_RELEASE) == MOUSE_RELEASE)
+                            stop_xterm_trace();
+                        else
+                            start_xterm_trace(mouse_code);
+                    }
 #   endif
 #  endif
-	    }
+                }
 # endif /* !UNIX || FEAT_MOUSE_XTERM */
 # ifdef FEAT_MOUSE_NET
-	    if (key_name[0] == (int)KS_NETTERM_MOUSE)
-	    {
-		int mc, mr;
-
-		/* expect a rather limited sequence like: balancing {
-		 * \033}6,45\r
-		 * '6' is the row, 45 is the column
-		 */
-		p = tp + slen;
-		mr = getdigits(&p);
-		if (*p++ != ',')
-		    return -1;
-		mc = getdigits(&p);
-		if (*p++ != '\r')
-		    return -1;
-
-		mouse_col = mc - 1;
-		mouse_row = mr - 1;
-		mouse_code = MOUSE_LEFT;
-		slen += (int)(p - (tp + slen));
-	    }
+                if (key_name[0] == (int)KS_NETTERM_MOUSE)
+                {
+                    int mc, mr;
+
+                    /* expect a rather limited sequence like: balancing {
+                     * \033}6,45\r
+                     * '6' is the row, 45 is the column
+                     */
+                    p = tp + slen;
+                    mr = getdigits(&p);
+                    if (*p++ != ',')
+                        return -1;
+                    mc = getdigits(&p);
+                    if (*p++ != '\r')
+                        return -1;
+
+                    mouse_col = mc - 1;
+                    mouse_row = mr - 1;
+                    mouse_code = MOUSE_LEFT;
+                    slen += (int)(p - (tp + slen));
+                }
 # endif	/* FEAT_MOUSE_NET */
 # ifdef FEAT_MOUSE_JSB
-	    if (key_name[0] == (int)KS_JSBTERM_MOUSE)
-	    {
-		int mult, val, iter, button, status;
-
-		/* JSBTERM Input Model
-		 * \033[0~zw uniq escape sequence
-		 * (L-x)  Left button pressed - not pressed x not reporting
-		 * (M-x)  Middle button pressed - not pressed x not reporting
-		 * (R-x)  Right button pressed - not pressed x not reporting
-		 * (SDmdu)  Single , Double click, m mouse move d button down
-		 *						   u button up
-		 *  ###   X cursor position padded to 3 digits
-		 *  ###   Y cursor position padded to 3 digits
-		 * (s-x)  SHIFT key pressed - not pressed x not reporting
-		 * (c-x)  CTRL key pressed - not pressed x not reporting
-		 * \033\\ terminating sequence
-		 */
-
-		p = tp + slen;
-		button = mouse_code = 0;
-		switch (*p++)
-		{
-		    case 'L': button = 1; break;
-		    case '-': break;
-		    case 'x': break; /* ignore sequence */
-		    default:  return -1; /* Unknown Result */
-		}
-		switch (*p++)
-		{
-		    case 'M': button |= 2; break;
-		    case '-': break;
-		    case 'x': break; /* ignore sequence */
-		    default:  return -1; /* Unknown Result */
-		}
-		switch (*p++)
-		{
-		    case 'R': button |= 4; break;
-		    case '-': break;
-		    case 'x': break; /* ignore sequence */
-		    default:  return -1; /* Unknown Result */
-		}
-		status = *p++;
-		for (val = 0, mult = 100, iter = 0; iter < 3; iter++,
-							      mult /= 10, p++)
-		    if (*p >= '0' && *p <= '9')
-			val += (*p - '0') * mult;
-		    else
-			return -1;
-		mouse_col = val;
-		for (val = 0, mult = 100, iter = 0; iter < 3; iter++,
-							      mult /= 10, p++)
-		    if (*p >= '0' && *p <= '9')
-			val += (*p - '0') * mult;
-		    else
-			return -1;
-		mouse_row = val;
-		switch (*p++)
-		{
-		    case 's': button |= 8; break;  /* SHIFT key Pressed */
-		    case '-': break;  /* Not Pressed */
-		    case 'x': break;  /* Not Reporting */
-		    default:  return -1; /* Unknown Result */
-		}
-		switch (*p++)
-		{
-		    case 'c': button |= 16; break;  /* CTRL key Pressed */
-		    case '-': break;  /* Not Pressed */
-		    case 'x': break;  /* Not Reporting */
-		    default:  return -1; /* Unknown Result */
-		}
-		if (*p++ != '\033')
-		    return -1;
-		if (*p++ != '\\')
-		    return -1;
-		switch (status)
-		{
-		    case 'D': /* Double Click */
-		    case 'S': /* Single Click */
-			if (button & 1) mouse_code |= MOUSE_LEFT;
-			if (button & 2) mouse_code |= MOUSE_MIDDLE;
-			if (button & 4) mouse_code |= MOUSE_RIGHT;
-			if (button & 8) mouse_code |= MOUSE_SHIFT;
-			if (button & 16) mouse_code |= MOUSE_CTRL;
-			break;
-		    case 'm': /* Mouse move */
-			if (button & 1) mouse_code |= MOUSE_LEFT;
-			if (button & 2) mouse_code |= MOUSE_MIDDLE;
-			if (button & 4) mouse_code |= MOUSE_RIGHT;
-			if (button & 8) mouse_code |= MOUSE_SHIFT;
-			if (button & 16) mouse_code |= MOUSE_CTRL;
-			if ((button & 7) != 0)
-			{
-			    held_button = mouse_code;
-			    mouse_code |= MOUSE_DRAG;
-			}
-			is_drag = TRUE;
-			showmode();
-			break;
-		    case 'd': /* Button Down */
-			if (button & 1) mouse_code |= MOUSE_LEFT;
-			if (button & 2) mouse_code |= MOUSE_MIDDLE;
-			if (button & 4) mouse_code |= MOUSE_RIGHT;
-			if (button & 8) mouse_code |= MOUSE_SHIFT;
-			if (button & 16) mouse_code |= MOUSE_CTRL;
-			break;
-		    case 'u': /* Button Up */
-			if (button & 1)
-			    mouse_code |= MOUSE_LEFT | MOUSE_RELEASE;
-			if (button & 2)
-			    mouse_code |= MOUSE_MIDDLE | MOUSE_RELEASE;
-			if (button & 4)
-			    mouse_code |= MOUSE_RIGHT | MOUSE_RELEASE;
-			if (button & 8)
-			    mouse_code |= MOUSE_SHIFT;
-			if (button & 16)
-			    mouse_code |= MOUSE_CTRL;
-			break;
-		    default: return -1; /* Unknown Result */
-		}
-
-		slen += (p - (tp + slen));
-	    }
+                if (key_name[0] == (int)KS_JSBTERM_MOUSE)
+                {
+                    int mult, val, iter, button, status;
+
+                    /* JSBTERM Input Model
+                     * \033[0~zw uniq escape sequence
+                     * (L-x)  Left button pressed - not pressed x not reporting
+                     * (M-x)  Middle button pressed - not pressed x not reporting
+                     * (R-x)  Right button pressed - not pressed x not reporting
+                     * (SDmdu)  Single , Double click, m mouse move d button down
+                     *						   u button up
+                     *  ###   X cursor position padded to 3 digits
+                     *  ###   Y cursor position padded to 3 digits
+                     * (s-x)  SHIFT key pressed - not pressed x not reporting
+                     * (c-x)  CTRL key pressed - not pressed x not reporting
+                     * \033\\ terminating sequence
+                     */
+
+                    p = tp + slen;
+                    button = mouse_code = 0;
+                    switch (*p++)
+                    {
+                        case 'L': button = 1; break;
+                        case '-': break;
+                        case 'x': break; /* ignore sequence */
+                        default:  return -1; /* Unknown Result */
+                    }
+                    switch (*p++)
+                    {
+                        case 'M': button |= 2; break;
+                        case '-': break;
+                        case 'x': break; /* ignore sequence */
+                        default:  return -1; /* Unknown Result */
+                    }
+                    switch (*p++)
+                    {
+                        case 'R': button |= 4; break;
+                        case '-': break;
+                        case 'x': break; /* ignore sequence */
+                        default:  return -1; /* Unknown Result */
+                    }
+                    status = *p++;
+                    for (val = 0, mult = 100, iter = 0; iter < 3; iter++,
+                            mult /= 10, p++)
+                        if (*p >= '0' && *p <= '9')
+                            val += (*p - '0') * mult;
+                        else
+                            return -1;
+                    mouse_col = val;
+                    for (val = 0, mult = 100, iter = 0; iter < 3; iter++,
+                            mult /= 10, p++)
+                        if (*p >= '0' && *p <= '9')
+                            val += (*p - '0') * mult;
+                        else
+                            return -1;
+                    mouse_row = val;
+                    switch (*p++)
+                    {
+                        case 's': button |= 8; break;  /* SHIFT key Pressed */
+                        case '-': break;  /* Not Pressed */
+                        case 'x': break;  /* Not Reporting */
+                        default:  return -1; /* Unknown Result */
+                    }
+                    switch (*p++)
+                    {
+                        case 'c': button |= 16; break;  /* CTRL key Pressed */
+                        case '-': break;  /* Not Pressed */
+                        case 'x': break;  /* Not Reporting */
+                        default:  return -1; /* Unknown Result */
+                    }
+                    if (*p++ != '\033')
+                        return -1;
+                    if (*p++ != '\\')
+                        return -1;
+                    switch (status)
+                    {
+                        case 'D': /* Double Click */
+                        case 'S': /* Single Click */
+                            if (button & 1) mouse_code |= MOUSE_LEFT;
+                            if (button & 2) mouse_code |= MOUSE_MIDDLE;
+                            if (button & 4) mouse_code |= MOUSE_RIGHT;
+                            if (button & 8) mouse_code |= MOUSE_SHIFT;
+                            if (button & 16) mouse_code |= MOUSE_CTRL;
+                            break;
+                        case 'm': /* Mouse move */
+                            if (button & 1) mouse_code |= MOUSE_LEFT;
+                            if (button & 2) mouse_code |= MOUSE_MIDDLE;
+                            if (button & 4) mouse_code |= MOUSE_RIGHT;
+                            if (button & 8) mouse_code |= MOUSE_SHIFT;
+                            if (button & 16) mouse_code |= MOUSE_CTRL;
+                            if ((button & 7) != 0)
+                            {
+                                held_button = mouse_code;
+                                mouse_code |= MOUSE_DRAG;
+                            }
+                            is_drag = TRUE;
+                            showmode();
+                            break;
+                        case 'd': /* Button Down */
+                            if (button & 1) mouse_code |= MOUSE_LEFT;
+                            if (button & 2) mouse_code |= MOUSE_MIDDLE;
+                            if (button & 4) mouse_code |= MOUSE_RIGHT;
+                            if (button & 8) mouse_code |= MOUSE_SHIFT;
+                            if (button & 16) mouse_code |= MOUSE_CTRL;
+                            break;
+                        case 'u': /* Button Up */
+                            if (button & 1)
+                                mouse_code |= MOUSE_LEFT | MOUSE_RELEASE;
+                            if (button & 2)
+                                mouse_code |= MOUSE_MIDDLE | MOUSE_RELEASE;
+                            if (button & 4)
+                                mouse_code |= MOUSE_RIGHT | MOUSE_RELEASE;
+                            if (button & 8)
+                                mouse_code |= MOUSE_SHIFT;
+                            if (button & 16)
+                                mouse_code |= MOUSE_CTRL;
+                            break;
+                        default: return -1; /* Unknown Result */
+                    }
+
+                    slen += (p - (tp + slen));
+                }
 # endif /* FEAT_MOUSE_JSB */
 # ifdef FEAT_MOUSE_DEC
-	    if (key_name[0] == (int)KS_DEC_MOUSE)
-	    {
-	       /* The DEC Locator Input Model
-		* Netterm delivers the code sequence:
-		*  \033[2;4;24;80&w  (left button down)
-		*  \033[3;0;24;80&w  (left button up)
-		*  \033[6;1;24;80&w  (right button down)
-		*  \033[7;0;24;80&w  (right button up)
-		* CSI Pe ; Pb ; Pr ; Pc ; Pp & w
-		* Pe is the event code
-		* Pb is the button code
-		* Pr is the row coordinate
-		* Pc is the column coordinate
-		* Pp is the third coordinate (page number)
-		* Pe, the event code indicates what event caused this report
-		*    The following event codes are defined:
-		*    0 - request, the terminal received an explicit request
-		*	 for a locator report, but the locator is unavailable
-		*    1 - request, the terminal received an explicit request
-		*	 for a locator report
-		*    2 - left button down
-		*    3 - left button up
-		*    4 - middle button down
-		*    5 - middle button up
-		*    6 - right button down
-		*    7 - right button up
-		*    8 - fourth button down
-		*    9 - fourth button up
-		*    10 - locator outside filter rectangle
-		* Pb, the button code, ASCII decimal 0-15 indicating which
-		*   buttons are down if any. The state of the four buttons
-		*   on the locator correspond to the low four bits of the
-		*   decimal value,
-		*   "1" means button depressed
-		*   0 - no buttons down,
-		*   1 - right,
-		*   2 - middle,
-		*   4 - left,
-		*   8 - fourth
-		* Pr is the row coordinate of the locator position in the page,
-		*   encoded as an ASCII decimal value.
-		*   If Pr is omitted, the locator position is undefined
-		*   (outside the terminal window for example).
-		* Pc is the column coordinate of the locator position in the
-		*   page, encoded as an ASCII decimal value.
-		*   If Pc is omitted, the locator position is undefined
-		*   (outside the terminal window for example).
-		* Pp is the page coordinate of the locator position
-		*   encoded as an ASCII decimal value.
-		*   The page coordinate may be omitted if the locator is on
-		*   page one (the default).  We ignore it anyway.
-		*/
-		int Pe, Pb, Pr, Pc;
-
-		p = tp + slen;
-
-		/* get event status */
-		Pe = getdigits(&p);
-		if (*p++ != ';')
-		    return -1;
-
-		/* get button status */
-		Pb = getdigits(&p);
-		if (*p++ != ';')
-		    return -1;
-
-		/* get row status */
-		Pr = getdigits(&p);
-		if (*p++ != ';')
-		    return -1;
-
-		/* get column status */
-		Pc = getdigits(&p);
-
-		/* the page parameter is optional */
-		if (*p == ';')
-		{
-		    p++;
-		    (void)getdigits(&p);
-		}
-		if (*p++ != '&')
-		    return -1;
-		if (*p++ != 'w')
-		    return -1;
-
-		mouse_code = 0;
-		switch (Pe)
-		{
-		case  0: return -1; /* position request while unavailable */
-		case  1: /* a response to a locator position request includes
-			    the status of all buttons */
-			 Pb &= 7;   /* mask off and ignore fourth button */
-			 if (Pb & 4)
-			     mouse_code  = MOUSE_LEFT;
-			 if (Pb & 2)
-			     mouse_code  = MOUSE_MIDDLE;
-			 if (Pb & 1)
-			     mouse_code  = MOUSE_RIGHT;
-			 if (Pb)
-			 {
-			     held_button = mouse_code;
-			     mouse_code |= MOUSE_DRAG;
-			     WantQueryMouse = TRUE;
-			 }
-			 is_drag = TRUE;
-			 showmode();
-			 break;
-		case  2: mouse_code = MOUSE_LEFT;
-			 WantQueryMouse = TRUE;
-			 break;
-		case  3: mouse_code = MOUSE_RELEASE | MOUSE_LEFT;
-			 break;
-		case  4: mouse_code = MOUSE_MIDDLE;
-			 WantQueryMouse = TRUE;
-			 break;
-		case  5: mouse_code = MOUSE_RELEASE | MOUSE_MIDDLE;
-			 break;
-		case  6: mouse_code = MOUSE_RIGHT;
-			 WantQueryMouse = TRUE;
-			 break;
-		case  7: mouse_code = MOUSE_RELEASE | MOUSE_RIGHT;
-			 break;
-		case  8: return -1; /* fourth button down */
-		case  9: return -1; /* fourth button up */
-		case 10: return -1; /* mouse outside of filter rectangle */
-		default: return -1; /* should never occur */
-		}
-
-		mouse_col = Pc - 1;
-		mouse_row = Pr - 1;
-
-		slen += (int)(p - (tp + slen));
-	    }
+                if (key_name[0] == (int)KS_DEC_MOUSE)
+                {
+                    /* The DEC Locator Input Model
+                     * Netterm delivers the code sequence:
+                     *  \033[2;4;24;80&w  (left button down)
+                     *  \033[3;0;24;80&w  (left button up)
+                     *  \033[6;1;24;80&w  (right button down)
+                     *  \033[7;0;24;80&w  (right button up)
+                     * CSI Pe ; Pb ; Pr ; Pc ; Pp & w
+                     * Pe is the event code
+                     * Pb is the button code
+                     * Pr is the row coordinate
+                     * Pc is the column coordinate
+                     * Pp is the third coordinate (page number)
+                     * Pe, the event code indicates what event caused this report
+                     *    The following event codes are defined:
+                     *    0 - request, the terminal received an explicit request
+                     *	 for a locator report, but the locator is unavailable
+                     *    1 - request, the terminal received an explicit request
+                     *	 for a locator report
+                     *    2 - left button down
+                     *    3 - left button up
+                     *    4 - middle button down
+                     *    5 - middle button up
+                     *    6 - right button down
+                     *    7 - right button up
+                     *    8 - fourth button down
+                     *    9 - fourth button up
+                     *    10 - locator outside filter rectangle
+                     * Pb, the button code, ASCII decimal 0-15 indicating which
+                     *   buttons are down if any. The state of the four buttons
+                     *   on the locator correspond to the low four bits of the
+                     *   decimal value,
+                     *   "1" means button depressed
+                     *   0 - no buttons down,
+                     *   1 - right,
+                     *   2 - middle,
+                     *   4 - left,
+                     *   8 - fourth
+                     * Pr is the row coordinate of the locator position in the page,
+                     *   encoded as an ASCII decimal value.
+                     *   If Pr is omitted, the locator position is undefined
+                     *   (outside the terminal window for example).
+                     * Pc is the column coordinate of the locator position in the
+                     *   page, encoded as an ASCII decimal value.
+                     *   If Pc is omitted, the locator position is undefined
+                     *   (outside the terminal window for example).
+                     * Pp is the page coordinate of the locator position
+                     *   encoded as an ASCII decimal value.
+                     *   The page coordinate may be omitted if the locator is on
+                     *   page one (the default).  We ignore it anyway.
+                     */
+                    int Pe, Pb, Pr, Pc;
+
+                    p = tp + slen;
+
+                    /* get event status */
+                    Pe = getdigits(&p);
+                    if (*p++ != ';')
+                        return -1;
+
+                    /* get button status */
+                    Pb = getdigits(&p);
+                    if (*p++ != ';')
+                        return -1;
+
+                    /* get row status */
+                    Pr = getdigits(&p);
+                    if (*p++ != ';')
+                        return -1;
+
+                    /* get column status */
+                    Pc = getdigits(&p);
+
+                    /* the page parameter is optional */
+                    if (*p == ';')
+                    {
+                        p++;
+                        (void)getdigits(&p);
+                    }
+                    if (*p++ != '&')
+                        return -1;
+                    if (*p++ != 'w')
+                        return -1;
+
+                    mouse_code = 0;
+                    switch (Pe)
+                    {
+                        case  0: return -1; /* position request while unavailable */
+                        case  1: /* a response to a locator position request includes
+                                    the status of all buttons */
+                                 Pb &= 7;   /* mask off and ignore fourth button */
+                                 if (Pb & 4)
+                                     mouse_code  = MOUSE_LEFT;
+                                 if (Pb & 2)
+                                     mouse_code  = MOUSE_MIDDLE;
+                                 if (Pb & 1)
+                                     mouse_code  = MOUSE_RIGHT;
+                                 if (Pb)
+                                 {
+                                     held_button = mouse_code;
+                                     mouse_code |= MOUSE_DRAG;
+                                     WantQueryMouse = TRUE;
+                                 }
+                                 is_drag = TRUE;
+                                 showmode();
+                                 break;
+                        case  2: mouse_code = MOUSE_LEFT;
+                                 WantQueryMouse = TRUE;
+                                 break;
+                        case  3: mouse_code = MOUSE_RELEASE | MOUSE_LEFT;
+                                 break;
+                        case  4: mouse_code = MOUSE_MIDDLE;
+                                 WantQueryMouse = TRUE;
+                                 break;
+                        case  5: mouse_code = MOUSE_RELEASE | MOUSE_MIDDLE;
+                                 break;
+                        case  6: mouse_code = MOUSE_RIGHT;
+                                 WantQueryMouse = TRUE;
+                                 break;
+                        case  7: mouse_code = MOUSE_RELEASE | MOUSE_RIGHT;
+                                 break;
+                        case  8: return -1; /* fourth button down */
+                        case  9: return -1; /* fourth button up */
+                        case 10: return -1; /* mouse outside of filter rectangle */
+                        default: return -1; /* should never occur */
+                    }
+
+                    mouse_col = Pc - 1;
+                    mouse_row = Pr - 1;
+
+                    slen += (int)(p - (tp + slen));
+                }
 # endif /* FEAT_MOUSE_DEC */
 # ifdef FEAT_MOUSE_PTERM
-	    if (key_name[0] == (int)KS_PTERM_MOUSE)
-	    {
-		int button, num_clicks, action;
-
-		p = tp + slen;
-
-		action = getdigits(&p);
-		if (*p++ != ';')
-		    return -1;
-
-		mouse_row = getdigits(&p);
-		if (*p++ != ';')
-		    return -1;
-		mouse_col = getdigits(&p);
-		if (*p++ != ';')
-		    return -1;
-
-		button = getdigits(&p);
-		mouse_code = 0;
-
-		switch( button )
-		{
-		    case 4: mouse_code = MOUSE_LEFT; break;
-		    case 1: mouse_code = MOUSE_RIGHT; break;
-		    case 2: mouse_code = MOUSE_MIDDLE; break;
-		    default: return -1;
-		}
-
-		switch( action )
-		{
-		    case 31: /* Initial press */
-			if (*p++ != ';')
-			    return -1;
-
-			num_clicks = getdigits(&p); /* Not used */
-			break;
-
-		    case 32: /* Release */
-			mouse_code |= MOUSE_RELEASE;
-			break;
-
-		    case 33: /* Drag */
-			held_button = mouse_code;
-			mouse_code |= MOUSE_DRAG;
-			break;
-
-		    default:
-			return -1;
-		}
-
-		if (*p++ != 't')
-		    return -1;
-
-		slen += (p - (tp + slen));
-	    }
+                if (key_name[0] == (int)KS_PTERM_MOUSE)
+                {
+                    int button, num_clicks, action;
+
+                    p = tp + slen;
+
+                    action = getdigits(&p);
+                    if (*p++ != ';')
+                        return -1;
+
+                    mouse_row = getdigits(&p);
+                    if (*p++ != ';')
+                        return -1;
+                    mouse_col = getdigits(&p);
+                    if (*p++ != ';')
+                        return -1;
+
+                    button = getdigits(&p);
+                    mouse_code = 0;
+
+                    switch( button )
+                    {
+                        case 4: mouse_code = MOUSE_LEFT; break;
+                        case 1: mouse_code = MOUSE_RIGHT; break;
+                        case 2: mouse_code = MOUSE_MIDDLE; break;
+                        default: return -1;
+                    }
+
+                    switch( action )
+                    {
+                        case 31: /* Initial press */
+                            if (*p++ != ';')
+                                return -1;
+
+                            num_clicks = getdigits(&p); /* Not used */
+                            break;
+
+                        case 32: /* Release */
+                            mouse_code |= MOUSE_RELEASE;
+                            break;
+
+                        case 33: /* Drag */
+                            held_button = mouse_code;
+                            mouse_code |= MOUSE_DRAG;
+                            break;
+
+                        default:
+                            return -1;
+                    }
+
+                    if (*p++ != 't')
+                        return -1;
+
+                    slen += (p - (tp + slen));
+                }
 # endif /* FEAT_MOUSE_PTERM */
 
-	    /* Interpret the mouse code */
-	    current_button = (mouse_code & MOUSE_CLICK_MASK);
-	    if (current_button == MOUSE_RELEASE
-# ifdef FEAT_MOUSE_XTERM
-		    && wheel_code == 0
-# endif
-		    )
-	    {
-		/*
-		 * If we get a mouse drag or release event when
-		 * there is no mouse button held down (held_button ==
-		 * MOUSE_RELEASE), produce a K_IGNORE below.
-		 * (can happen when you hold down two buttons
-		 * and then let them go, or click in the menu bar, but not
-		 * on a menu, and drag into the text).
-		 */
-		if ((mouse_code & MOUSE_DRAG) == MOUSE_DRAG)
-		    is_drag = TRUE;
-		current_button = held_button;
-	    }
-	    else if (wheel_code == 0)
-	    {
-# ifdef CHECK_DOUBLE_CLICK
-#  ifdef FEAT_MOUSE_GPM
-#   ifdef FEAT_GUI
-		/*
-		 * Only for Unix, when GUI or gpm is not active, we handle
-		 * multi-clicks here.
-		 */
-		if (gpm_flag == 0 && !gui.in_use)
-#   else
-		if (gpm_flag == 0)
-#   endif
-#  else
-#   ifdef FEAT_GUI
-		if (!gui.in_use)
-#   endif
-#  endif
-		{
-		    /*
-		     * Compute the time elapsed since the previous mouse click.
-		     */
-		    gettimeofday(&mouse_time, NULL);
-		    if (orig_mouse_time.tv_sec == 0)
-		    {
-			/*
-			 * Avoid computing the difference between mouse_time
-			 * and orig_mouse_time for the first click, as the
-			 * difference would be huge and would cause multiplication
-			 * overflow.
-			 */
-			timediff = p_mouset;
-		    }
-		    else
-		    {
-			timediff = (mouse_time.tv_usec
-						- orig_mouse_time.tv_usec) / 1000;
-			if (timediff < 0)
-			    --orig_mouse_time.tv_sec;
-			timediff += (mouse_time.tv_sec
-						 - orig_mouse_time.tv_sec) * 1000;
-		    }
-		    orig_mouse_time = mouse_time;
-		    if (mouse_code == orig_mouse_code
-			    && timediff < p_mouset
-			    && orig_num_clicks != 4
-			    && orig_mouse_col == mouse_col
-			    && orig_mouse_row == mouse_row
-			    && ((orig_topline == curwin->w_topline
+                /* Interpret the mouse code */
+                current_button = (mouse_code & MOUSE_CLICK_MASK);
+                if (current_button == MOUSE_RELEASE && wheel_code == 0)
+                {
+                    /*
+                     * If we get a mouse drag or release event when
+                     * there is no mouse button held down (held_button ==
+                     * MOUSE_RELEASE), produce a K_IGNORE below.
+                     * (can happen when you hold down two buttons
+                     * and then let them go, or click in the menu bar, but not
+                     * on a menu, and drag into the text).
+                     */
+                    if ((mouse_code & MOUSE_DRAG) == MOUSE_DRAG) {
+                        is_drag = TRUE;
+                    }
+                    current_button = held_button;
+                }
+                else if (wheel_code == 0)
+                {
+                    /*
+                     * Only for Unix, when GUI or gpm is not active, we handle
+                     * multi-clicks here.
+                     */
+                    if (gpm_flag == 0 && !gui.in_use)
+                        if (gpm_flag == 0)
+                            if (!gui.in_use)
+                            {
+                                /*
+                                 * Compute the time elapsed since the previous mouse click.
+                                 */
+                                gettimeofday(&mouse_time, NULL);
+                                if (orig_mouse_time.tv_sec == 0)
+                                {
+                                    /*
+                                     * Avoid computing the difference between mouse_time
+                                     * and orig_mouse_time for the first click, as the
+                                     * difference would be huge and would cause multiplication
+                                     * overflow.
+                                     */
+                                    timediff = p_mouset;
+                                }
+                                else
+                                {
+                                    timediff = (mouse_time.tv_usec
+                                            - orig_mouse_time.tv_usec) / 1000;
+                                    if (timediff < 0)
+                                        --orig_mouse_time.tv_sec;
+                                    timediff += (mouse_time.tv_sec
+                                            - orig_mouse_time.tv_sec) * 1000;
+                                }
+                                lp("/tmp/log1", "------------------------------------------------\n");
+                                lp("/tmp/log1", "mouse_code = %d | orig_mouse_code = %d\n", mouse_code, orig_mouse_code);
+                                lp("/tmp/log1", "time_diff = %lu | mouset = %d\n", timediff, p_mouset);
+                                lp("/tmp/log1", "orig_num_clicks = %d\n", orig_num_clicks);
+                                lp("/tmp/log1", "mouse_code == orig_mouse_code: %s\n", mouse_code == orig_mouse_code? "True": "False");
+                                lp("/tmp/log1", "timediff < mouset : %s\n", timediff < p_mouset ? "True": "False");
+                                lp("/tmp/log1", "------------------------------------------------\n");
+
+                                orig_mouse_time = mouse_time;
+                                if (mouse_code == orig_mouse_code
+                                        && timediff < p_mouset
+                                        && orig_num_clicks != 4
+                                        && orig_mouse_col == mouse_col
+                                        && orig_mouse_row == mouse_row
+                                        && ((orig_topline == curwin->w_topline
 #ifdef FEAT_DIFF
-				    && orig_topfill == curwin->w_topfill
+                                                && orig_topfill == curwin->w_topfill
 #endif
-				)
+                                            )
 #ifdef FEAT_WINDOWS
-				/* Double click in tab pages line also works
-				 * when window contents changes. */
-				|| (mouse_row == 0 && firstwin->w_winrow > 0)
-#endif
-			       )
-			    )
-			++orig_num_clicks;
-		    else
-			orig_num_clicks = 1;
-		    orig_mouse_col = mouse_col;
-		    orig_mouse_row = mouse_row;
-		    orig_topline = curwin->w_topline;
+                                            /* Double click in tab pages line also works
+                                             * when window contents changes. */
+                                            || (mouse_row == 0 && firstwin->w_winrow > 0)
+#endif
+                                           )
+                                   )
+                                    ++orig_num_clicks;
+                                else
+                                    orig_num_clicks = 1;
+                                orig_mouse_col = mouse_col;
+                                orig_mouse_row = mouse_row;
+                                orig_topline = curwin->w_topline;
 #ifdef FEAT_DIFF
-		    orig_topfill = curwin->w_topfill;
+                                orig_topfill = curwin->w_topfill;
 #endif
-		}
+                            }
 #  if defined(FEAT_GUI) || defined(FEAT_MOUSE_GPM)
-		else
-		    orig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);
+                            else
+                                orig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);
 #  endif
 # else
-		orig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);
+                    orig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);
 # endif
-		is_click = TRUE;
-		orig_mouse_code = mouse_code;
-	    }
-	    if (!is_drag)
-		held_button = mouse_code & MOUSE_CLICK_MASK;
-
-	    /*
-	     * Translate the actual mouse event into a pseudo mouse event.
-	     * First work out what modifiers are to be used.
-	     */
-	    if (orig_mouse_code & MOUSE_SHIFT)
-		modifiers |= MOD_MASK_SHIFT;
-	    if (orig_mouse_code & MOUSE_CTRL)
-		modifiers |= MOD_MASK_CTRL;
-	    if (orig_mouse_code & MOUSE_ALT)
-		modifiers |= MOD_MASK_ALT;
-	    if (orig_num_clicks == 2)
-		modifiers |= MOD_MASK_2CLICK;
-	    else if (orig_num_clicks == 3)
-		modifiers |= MOD_MASK_3CLICK;
-	    else if (orig_num_clicks == 4)
-		modifiers |= MOD_MASK_4CLICK;
-
-	    /* Work out our pseudo mouse event */
-	    key_name[0] = (int)KS_EXTRA;
-	    if (wheel_code != 0)
-	    {
-		if (wheel_code & MOUSE_CTRL)
-		    modifiers |= MOD_MASK_CTRL;
-		if (wheel_code & MOUSE_ALT)
-		    modifiers |= MOD_MASK_ALT;
-		key_name[1] = (wheel_code & 1)
-					? (int)KE_MOUSEUP : (int)KE_MOUSEDOWN;
-	    }
-	    else
-		key_name[1] = get_pseudo_mouse_code(current_button,
-							   is_click, is_drag);
-
-	    /* Make sure the mouse position is valid.  Some terminals may
-	     * return weird values. */
-	    if (mouse_col >= Columns)
-		mouse_col = Columns - 1;
-	    if (mouse_row >= Rows)
-		mouse_row = Rows - 1;
-	}
+                    is_click = TRUE;
+                    orig_mouse_code = mouse_code;
+                }
+                if (!is_drag)
+                    held_button = mouse_code & MOUSE_CLICK_MASK;
+
+                /*
+                 * Translate the actual mouse event into a pseudo mouse event.
+                 * First work out what modifiers are to be used.
+                 */
+                if (orig_mouse_code & MOUSE_SHIFT)
+                    modifiers |= MOD_MASK_SHIFT;
+                if (orig_mouse_code & MOUSE_CTRL)
+                    modifiers |= MOD_MASK_CTRL;
+                if (orig_mouse_code & MOUSE_ALT)
+                    modifiers |= MOD_MASK_ALT;
+                if (orig_num_clicks == 2)
+                    modifiers |= MOD_MASK_2CLICK;
+                else if (orig_num_clicks == 3)
+                    modifiers |= MOD_MASK_3CLICK;
+                else if (orig_num_clicks == 4)
+                    modifiers |= MOD_MASK_4CLICK;
+
+                /* Work out our pseudo mouse event */
+                key_name[0] = (int)KS_EXTRA;
+                if (wheel_code != 0)
+                {
+                    if (wheel_code & MOUSE_CTRL)
+                        modifiers |= MOD_MASK_CTRL;
+                    if (wheel_code & MOUSE_ALT)
+                        modifiers |= MOD_MASK_ALT;
+                    key_name[1] = (wheel_code & 1)
+                        ? (int)KE_MOUSEUP : (int)KE_MOUSEDOWN;
+                }
+                else
+                    key_name[1] = get_pseudo_mouse_code(current_button, is_click, is_drag);
+
+                /* Make sure the mouse position is valid.  Some terminals may
+                 * return weird values. */
+                if (mouse_col >= Columns)
+                    mouse_col = Columns - 1;
+                if (mouse_row >= Rows)
+                    mouse_row = Rows - 1;
+            }
 #endif /* FEAT_MOUSE */
 
 #ifdef FEAT_GUI
-	/*
-	 * If using the GUI, then we get menu and scrollbar events.
-	 *
-	 * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by
-	 * four bytes which are to be taken as a pointer to the vimmenu_T
-	 * structure.
-	 *
-	 * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where "nr"
-	 * is one byte with the tab index.
-	 *
-	 * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed
-	 * by one byte representing the scrollbar number, and then four bytes
-	 * representing a long_u which is the new value of the scrollbar.
-	 *
-	 * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,
-	 * KE_FILLER followed by four bytes representing a long_u which is the
-	 * new value of the scrollbar.
-	 */
+        /*
+         * If using the GUI, then we get menu and scrollbar events.
+         *
+         * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by
+         * four bytes which are to be taken as a pointer to the vimmenu_T
+         * structure.
+         *
+         * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where "nr"
+         * is one byte with the tab index.
+         *
+         * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed
+         * by one byte representing the scrollbar number, and then four bytes
+         * representing a long_u which is the new value of the scrollbar.
+         *
+         * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,
+         * KE_FILLER followed by four bytes representing a long_u which is the
+         * new value of the scrollbar.
+         */
 # ifdef FEAT_MENU
-	else if (key_name[0] == (int)KS_MENU)
-	{
-	    long_u	val;
-
-	    num_bytes = get_long_from_buf(tp + slen, &val);
-	    if (num_bytes == -1)
-		return -1;
-	    current_menu = (vimmenu_T *)val;
-	    slen += num_bytes;
-
-	    /* The menu may have been deleted right after it was used, check
-	     * for that. */
-	    if (check_menu_pointer(root_menu, current_menu) == FAIL)
-	    {
-		key_name[0] = KS_EXTRA;
-		key_name[1] = (int)KE_IGNORE;
-	    }
-	}
+            else if (key_name[0] == (int)KS_MENU)
+            {
+                long_u	val;
+
+                num_bytes = get_long_from_buf(tp + slen, &val);
+                if (num_bytes == -1)
+                    return -1;
+                current_menu = (vimmenu_T *)val;
+                slen += num_bytes;
+
+                /* The menu may have been deleted right after it was used, check
+                 * for that. */
+                if (check_menu_pointer(root_menu, current_menu) == FAIL)
+                {
+                    key_name[0] = KS_EXTRA;
+                    key_name[1] = (int)KE_IGNORE;
+                }
+            }
 # endif
 # ifdef FEAT_GUI_TABLINE
-	else if (key_name[0] == (int)KS_TABLINE)
-	{
-	    /* Selecting tabline tab or using its menu. */
-	    num_bytes = get_bytes_from_buf(tp + slen, bytes, 1);
-	    if (num_bytes == -1)
-		return -1;
-	    current_tab = (int)bytes[0];
-	    if (current_tab == 255)	/* -1 in a byte gives 255 */
-		current_tab = -1;
-	    slen += num_bytes;
-	}
-	else if (key_name[0] == (int)KS_TABMENU)
-	{
-	    /* Selecting tabline tab or using its menu. */
-	    num_bytes = get_bytes_from_buf(tp + slen, bytes, 2);
-	    if (num_bytes == -1)
-		return -1;
-	    current_tab = (int)bytes[0];
-	    current_tabmenu = (int)bytes[1];
-	    slen += num_bytes;
-	}
+            else if (key_name[0] == (int)KS_TABLINE)
+            {
+                /* Selecting tabline tab or using its menu. */
+                num_bytes = get_bytes_from_buf(tp + slen, bytes, 1);
+                if (num_bytes == -1)
+                    return -1;
+                current_tab = (int)bytes[0];
+                if (current_tab == 255)	/* -1 in a byte gives 255 */
+                    current_tab = -1;
+                slen += num_bytes;
+            }
+            else if (key_name[0] == (int)KS_TABMENU)
+            {
+                /* Selecting tabline tab or using its menu. */
+                num_bytes = get_bytes_from_buf(tp + slen, bytes, 2);
+                if (num_bytes == -1)
+                    return -1;
+                current_tab = (int)bytes[0];
+                current_tabmenu = (int)bytes[1];
+                slen += num_bytes;
+            }
 # endif
 # ifndef USE_ON_FLY_SCROLL
-	else if (key_name[0] == (int)KS_VER_SCROLLBAR)
-	{
-	    long_u	val;
-
-	    /* Get the last scrollbar event in the queue of the same type */
-	    j = 0;
-	    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR
-						     && tp[j + 2] != NUL; ++i)
-	    {
-		j += 3;
-		num_bytes = get_bytes_from_buf(tp + j, bytes, 1);
-		if (num_bytes == -1)
-		    break;
-		if (i == 0)
-		    current_scrollbar = (int)bytes[0];
-		else if (current_scrollbar != (int)bytes[0])
-		    break;
-		j += num_bytes;
-		num_bytes = get_long_from_buf(tp + j, &val);
-		if (num_bytes == -1)
-		    break;
-		scrollbar_value = val;
-		j += num_bytes;
-		slen = j;
-	    }
-	    if (i == 0)		/* not enough characters to make one */
-		return -1;
-	}
-	else if (key_name[0] == (int)KS_HOR_SCROLLBAR)
-	{
-	    long_u	val;
-
-	    /* Get the last horiz. scrollbar event in the queue */
-	    j = 0;
-	    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR
-						     && tp[j + 2] != NUL; ++i)
-	    {
-		j += 3;
-		num_bytes = get_long_from_buf(tp + j, &val);
-		if (num_bytes == -1)
-		    break;
-		scrollbar_value = val;
-		j += num_bytes;
-		slen = j;
-	    }
-	    if (i == 0)		/* not enough characters to make one */
-		return -1;
-	}
+            else if (key_name[0] == (int)KS_VER_SCROLLBAR)
+            {
+                long_u	val;
+
+                /* Get the last scrollbar event in the queue of the same type */
+                j = 0;
+                for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR
+                        && tp[j + 2] != NUL; ++i)
+                {
+                    j += 3;
+                    num_bytes = get_bytes_from_buf(tp + j, bytes, 1);
+                    if (num_bytes == -1)
+                        break;
+                    if (i == 0)
+                        current_scrollbar = (int)bytes[0];
+                    else if (current_scrollbar != (int)bytes[0])
+                        break;
+                    j += num_bytes;
+                    num_bytes = get_long_from_buf(tp + j, &val);
+                    if (num_bytes == -1)
+                        break;
+                    scrollbar_value = val;
+                    j += num_bytes;
+                    slen = j;
+                }
+                if (i == 0)		/* not enough characters to make one */
+                    return -1;
+            }
+            else if (key_name[0] == (int)KS_HOR_SCROLLBAR)
+            {
+                long_u	val;
+
+                /* Get the last horiz. scrollbar event in the queue */
+                j = 0;
+                for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR
+                        && tp[j + 2] != NUL; ++i)
+                {
+                    j += 3;
+                    num_bytes = get_long_from_buf(tp + j, &val);
+                    if (num_bytes == -1)
+                        break;
+                    scrollbar_value = val;
+                    j += num_bytes;
+                    slen = j;
+                }
+                if (i == 0)		/* not enough characters to make one */
+                    return -1;
+            }
 # endif /* !USE_ON_FLY_SCROLL */
 #endif /* FEAT_GUI */
 
-	/*
-	 * Change <xHome> to <Home>, <xUp> to <Up>, etc.
-	 */
-	key = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));
-
-	/*
-	 * Add any modifier codes to our string.
-	 */
-	new_slen = 0;		/* Length of what will replace the termcode */
-	if (modifiers != 0)
-	{
-	    /* Some keys have the modifier included.  Need to handle that here
-	     * to make mappings work. */
-	    key = simplify_key(key, &modifiers);
-	    if (modifiers != 0)
-	    {
-		string[new_slen++] = K_SPECIAL;
-		string[new_slen++] = (int)KS_MODIFIER;
-		string[new_slen++] = modifiers;
-	    }
-	}
-
-	/* Finally, add the special key code to our string */
-	key_name[0] = KEY2TERMCAP0(key);
-	key_name[1] = KEY2TERMCAP1(key);
-	if (key_name[0] == KS_KEY)
-	{
-	    /* from ":set <M-b>=xx" */
+        /*
+         * Change <xHome> to <Home>, <xUp> to <Up>, etc.
+         */
+        key = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));
+
+        /*
+         * Add any modifier codes to our string.
+         */
+        new_slen = 0;		/* Length of what will replace the termcode */
+        if (modifiers != 0)
+        {
+            /* Some keys have the modifier included.  Need to handle that here
+             * to make mappings work. */
+            key = simplify_key(key, &modifiers);
+            if (modifiers != 0)
+            {
+                string[new_slen++] = K_SPECIAL;
+                string[new_slen++] = (int)KS_MODIFIER;
+                string[new_slen++] = modifiers;
+            }
+        }
+
+        /* Finally, add the special key code to our string */
+        key_name[0] = KEY2TERMCAP0(key);
+        key_name[1] = KEY2TERMCAP1(key);
+        if (key_name[0] == KS_KEY)
+        {
+            /* from ":set <M-b>=xx" */
 #ifdef FEAT_MBYTE
-	    if (has_mbyte)
-		new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);
-	    else
-#endif
-		string[new_slen++] = key_name[1];
-	}
-	else if (new_slen == 0 && key_name[0] == KS_EXTRA
-						  && key_name[1] == KE_IGNORE)
-	{
-	    /* Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED
-	     * to indicate what happened. */
-	    retval = KEYLEN_REMOVED;
-	}
-	else
-	{
-	    string[new_slen++] = K_SPECIAL;
-	    string[new_slen++] = key_name[0];
-	    string[new_slen++] = key_name[1];
-	}
-	string[new_slen] = NUL;
-	extra = new_slen - slen;
-	if (buf == NULL)
-	{
-	    if (extra < 0)
-		/* remove matched chars, taking care of noremap */
-		del_typebuf(-extra, offset);
-	    else if (extra > 0)
-		/* insert the extra space we need */
-		ins_typebuf(string + slen, REMAP_YES, offset, FALSE, FALSE);
-
-	    /*
-	     * Careful: del_typebuf() and ins_typebuf() may have reallocated
-	     * typebuf.tb_buf[]!
-	     */
-	    mch_memmove(typebuf.tb_buf + typebuf.tb_off + offset, string,
-							    (size_t)new_slen);
-	}
-	else
-	{
-	    if (extra < 0)
-		/* remove matched characters */
-		mch_memmove(buf + offset, buf + offset - extra,
-					   (size_t)(*buflen + offset + extra));
-	    else if (extra > 0)
-	    {
-		/* Insert the extra space we need.  If there is insufficient
-		 * space return -1. */
-		if (*buflen + extra + new_slen >= bufsize)
-		    return -1;
-		mch_memmove(buf + offset + extra, buf + offset,
-						   (size_t)(*buflen - offset));
-	    }
-	    mch_memmove(buf + offset, string, (size_t)new_slen);
-	    *buflen = *buflen + extra + new_slen;
-	}
-	return retval == 0 ? (len + extra + offset) : retval;
+            if (has_mbyte)
+                new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);
+            else
+#endif
+                string[new_slen++] = key_name[1];
+        }
+        else if (new_slen == 0 && key_name[0] == KS_EXTRA
+                && key_name[1] == KE_IGNORE)
+        {
+            /* Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED
+             * to indicate what happened. */
+            retval = KEYLEN_REMOVED;
+        }
+        else
+        {
+            string[new_slen++] = K_SPECIAL;
+            string[new_slen++] = key_name[0];
+            string[new_slen++] = key_name[1];
+        }
+        string[new_slen] = NUL;
+        extra = new_slen - slen;
+        if (buf == NULL)
+        {
+            if (extra < 0)
+                /* remove matched chars, taking care of noremap */
+                del_typebuf(-extra, offset);
+            else if (extra > 0)
+                /* insert the extra space we need */
+                ins_typebuf(string + slen, REMAP_YES, offset, FALSE, FALSE);
+
+            /*
+             * Careful: del_typebuf() and ins_typebuf() may have reallocated
+             * typebuf.tb_buf[]!
+             */
+            mch_memmove(typebuf.tb_buf + typebuf.tb_off + offset, string,
+                    (size_t)new_slen);
+        }
+        else
+        {
+            if (extra < 0)
+                /* remove matched characters */
+                mch_memmove(buf + offset, buf + offset - extra,
+                        (size_t)(*buflen + offset + extra));
+            else if (extra > 0)
+            {
+                /* Insert the extra space we need.  If there is insufficient
+                 * space return -1. */
+                if (*buflen + extra + new_slen >= bufsize)
+                    return -1;
+                mch_memmove(buf + offset + extra, buf + offset,
+                        (size_t)(*buflen - offset));
+            }
+            mch_memmove(buf + offset, string, (size_t)new_slen);
+            *buflen = *buflen + extra + new_slen;
+        }
+        return retval == 0 ? (len + extra + offset) : retval;
     }
 
 #ifdef FEAT_TERMRESPONSE
@@ -5358,13 +5368,13 @@ check_termcode(
  * nothing).  When 'cpoptions' does not contain 'B', a backslash can be used
  * instead of a CTRL-V.
  */
-    char_u *
+char_u *
 replace_termcodes(
-    char_u	*from,
-    char_u	**bufp,
-    int		from_part,
-    int		do_lt,		/* also translate <lt> */
-    int		special)	/* always accept <key> notation */
+        char_u	*from,
+        char_u	**bufp,
+        int		from_part,
+        int		do_lt,		/* also translate <lt> */
+        int		special)	/* always accept <key> notation */
 {
     int		i;
     int		slen;
@@ -5387,8 +5397,8 @@ replace_termcodes(
     result = alloc((unsigned)STRLEN(from) * 6 + 1);
     if (result == NULL)		/* out of memory */
     {
-	*bufp = NULL;
-	return from;
+        *bufp = NULL;
+        return from;
     }
 
     src = from;
@@ -5398,13 +5408,13 @@ replace_termcodes(
      */
     if (from_part && src[0] == '#' && VIM_ISDIGIT(src[1]))  /* function key */
     {
-	result[dlen++] = K_SPECIAL;
-	result[dlen++] = 'k';
-	if (src[1] == '0')
-	    result[dlen++] = ';';	/* #0 is F10 is "k;" */
-	else
-	    result[dlen++] = src[1];	/* #3 is F3 is "k3" */
-	src += 2;
+        result[dlen++] = K_SPECIAL;
+        result[dlen++] = 'k';
+        if (src[1] == '0')
+            result[dlen++] = ';';	/* #0 is F10 is "k;" */
+        else
+            result[dlen++] = src[1];	/* #3 is F3 is "k3" */
+        src += 2;
     }
 
     /*
@@ -5412,149 +5422,149 @@ replace_termcodes(
      */
     while (*src != NUL)
     {
-	/*
-	 * If 'cpoptions' does not contain '<', check for special key codes,
-	 * like "<C-S-LeftMouse>"
-	 */
-	if (do_special && (do_lt || STRNCMP(src, "<lt>", 4) != 0))
-	{
+        /*
+         * If 'cpoptions' does not contain '<', check for special key codes,
+         * like "<C-S-LeftMouse>"
+         */
+        if (do_special && (do_lt || STRNCMP(src, "<lt>", 4) != 0))
+        {
 #ifdef FEAT_EVAL
-	    /*
-	     * Replace <SID> by K_SNR <script-nr> _.
-	     * (room: 5 * 6 = 30 bytes; needed: 3 + <nr> + 1 <= 14)
-	     */
-	    if (STRNICMP(src, "<SID>", 5) == 0)
-	    {
-		if (current_SID <= 0)
-		    EMSG(_(e_usingsid));
-		else
-		{
-		    src += 5;
-		    result[dlen++] = K_SPECIAL;
-		    result[dlen++] = (int)KS_EXTRA;
-		    result[dlen++] = (int)KE_SNR;
-		    sprintf((char *)result + dlen, "%ld", (long)current_SID);
-		    dlen += (int)STRLEN(result + dlen);
-		    result[dlen++] = '_';
-		    continue;
-		}
-	    }
-#endif
-
-	    slen = trans_special(&src, result + dlen, TRUE);
-	    if (slen)
-	    {
-		dlen += slen;
-		continue;
-	    }
-	}
-
-	/*
-	 * If 'cpoptions' does not contain 'k', see if it's an actual key-code.
-	 * Note that this is also checked after replacing the <> form.
-	 * Single character codes are NOT replaced (e.g. ^H or DEL), because
-	 * it could be a character in the file.
-	 */
-	if (do_key_code)
-	{
-	    i = find_term_bykeys(src);
-	    if (i >= 0)
-	    {
-		result[dlen++] = K_SPECIAL;
-		result[dlen++] = termcodes[i].name[0];
-		result[dlen++] = termcodes[i].name[1];
-		src += termcodes[i].len;
-		/* If terminal code matched, continue after it. */
-		continue;
-	    }
-	}
+            /*
+             * Replace <SID> by K_SNR <script-nr> _.
+             * (room: 5 * 6 = 30 bytes; needed: 3 + <nr> + 1 <= 14)
+             */
+            if (STRNICMP(src, "<SID>", 5) == 0)
+            {
+                if (current_SID <= 0)
+                    EMSG(_(e_usingsid));
+                else
+                {
+                    src += 5;
+                    result[dlen++] = K_SPECIAL;
+                    result[dlen++] = (int)KS_EXTRA;
+                    result[dlen++] = (int)KE_SNR;
+                    sprintf((char *)result + dlen, "%ld", (long)current_SID);
+                    dlen += (int)STRLEN(result + dlen);
+                    result[dlen++] = '_';
+                    continue;
+                }
+            }
+#endif
+
+            slen = trans_special(&src, result + dlen, TRUE);
+            if (slen)
+            {
+                dlen += slen;
+                continue;
+            }
+        }
+
+        /*
+         * If 'cpoptions' does not contain 'k', see if it's an actual key-code.
+         * Note that this is also checked after replacing the <> form.
+         * Single character codes are NOT replaced (e.g. ^H or DEL), because
+         * it could be a character in the file.
+         */
+        if (do_key_code)
+        {
+            i = find_term_bykeys(src);
+            if (i >= 0)
+            {
+                result[dlen++] = K_SPECIAL;
+                result[dlen++] = termcodes[i].name[0];
+                result[dlen++] = termcodes[i].name[1];
+                src += termcodes[i].len;
+                /* If terminal code matched, continue after it. */
+                continue;
+            }
+        }
 
 #ifdef FEAT_EVAL
-	if (do_special)
-	{
-	    char_u	*p, *s, len;
-
-	    /*
-	     * Replace <Leader> by the value of "mapleader".
-	     * Replace <LocalLeader> by the value of "maplocalleader".
-	     * If "mapleader" or "maplocalleader" isn't set use a backslash.
-	     */
-	    if (STRNICMP(src, "<Leader>", 8) == 0)
-	    {
-		len = 8;
-		p = get_var_value((char_u *)"g:mapleader");
-	    }
-	    else if (STRNICMP(src, "<LocalLeader>", 13) == 0)
-	    {
-		len = 13;
-		p = get_var_value((char_u *)"g:maplocalleader");
-	    }
-	    else
-	    {
-		len = 0;
-		p = NULL;
-	    }
-	    if (len != 0)
-	    {
-		/* Allow up to 8 * 6 characters for "mapleader". */
-		if (p == NULL || *p == NUL || STRLEN(p) > 8 * 6)
-		    s = (char_u *)"\\";
-		else
-		    s = p;
-		while (*s != NUL)
-		    result[dlen++] = *s++;
-		src += len;
-		continue;
-	    }
-	}
-#endif
-
-	/*
-	 * Remove CTRL-V and ignore the next character.
-	 * For "from" side the CTRL-V at the end is included, for the "to"
-	 * part it is removed.
-	 * If 'cpoptions' does not contain 'B', also accept a backslash.
-	 */
-	key = *src;
-	if (key == Ctrl_V || (do_backslash && key == '\\'))
-	{
-	    ++src;				/* skip CTRL-V or backslash */
-	    if (*src == NUL)
-	    {
-		if (from_part)
-		    result[dlen++] = key;
-		break;
-	    }
-	}
+        if (do_special)
+        {
+            char_u	*p, *s, len;
+
+            /*
+             * Replace <Leader> by the value of "mapleader".
+             * Replace <LocalLeader> by the value of "maplocalleader".
+             * If "mapleader" or "maplocalleader" isn't set use a backslash.
+             */
+            if (STRNICMP(src, "<Leader>", 8) == 0)
+            {
+                len = 8;
+                p = get_var_value((char_u *)"g:mapleader");
+            }
+            else if (STRNICMP(src, "<LocalLeader>", 13) == 0)
+            {
+                len = 13;
+                p = get_var_value((char_u *)"g:maplocalleader");
+            }
+            else
+            {
+                len = 0;
+                p = NULL;
+            }
+            if (len != 0)
+            {
+                /* Allow up to 8 * 6 characters for "mapleader". */
+                if (p == NULL || *p == NUL || STRLEN(p) > 8 * 6)
+                    s = (char_u *)"\\";
+                else
+                    s = p;
+                while (*s != NUL)
+                    result[dlen++] = *s++;
+                src += len;
+                continue;
+            }
+        }
+#endif
+
+        /*
+         * Remove CTRL-V and ignore the next character.
+         * For "from" side the CTRL-V at the end is included, for the "to"
+         * part it is removed.
+         * If 'cpoptions' does not contain 'B', also accept a backslash.
+         */
+        key = *src;
+        if (key == Ctrl_V || (do_backslash && key == '\\'))
+        {
+            ++src;				/* skip CTRL-V or backslash */
+            if (*src == NUL)
+            {
+                if (from_part)
+                    result[dlen++] = key;
+                break;
+            }
+        }
 
 #ifdef FEAT_MBYTE
-	/* skip multibyte char correctly */
-	for (i = (*mb_ptr2len)(src); i > 0; --i)
-#endif
-	{
-	    /*
-	     * If the character is K_SPECIAL, replace it with K_SPECIAL
-	     * KS_SPECIAL KE_FILLER.
-	     * If compiled with the GUI replace CSI with K_CSI.
-	     */
-	    if (*src == K_SPECIAL)
-	    {
-		result[dlen++] = K_SPECIAL;
-		result[dlen++] = KS_SPECIAL;
-		result[dlen++] = KE_FILLER;
-	    }
+        /* skip multibyte char correctly */
+        for (i = (*mb_ptr2len)(src); i > 0; --i)
+#endif
+        {
+            /*
+             * If the character is K_SPECIAL, replace it with K_SPECIAL
+             * KS_SPECIAL KE_FILLER.
+             * If compiled with the GUI replace CSI with K_CSI.
+             */
+            if (*src == K_SPECIAL)
+            {
+                result[dlen++] = K_SPECIAL;
+                result[dlen++] = KS_SPECIAL;
+                result[dlen++] = KE_FILLER;
+            }
 # ifdef FEAT_GUI
-	    else if (*src == CSI)
-	    {
-		result[dlen++] = K_SPECIAL;
-		result[dlen++] = KS_EXTRA;
-		result[dlen++] = (int)KE_CSI;
-	    }
+            else if (*src == CSI)
+            {
+                result[dlen++] = K_SPECIAL;
+                result[dlen++] = KS_EXTRA;
+                result[dlen++] = (int)KE_CSI;
+            }
 # endif
-	    else
-		result[dlen++] = *src;
-	    ++src;
-	}
+            else
+                result[dlen++] = *src;
+            ++src;
+        }
     }
     result[dlen] = NUL;
 
@@ -5563,7 +5573,7 @@ replace_termcodes(
      * If this fails, just return from.
      */
     if ((*bufp = vim_strsave(result)) != NULL)
-	from = *bufp;
+        from = *bufp;
     vim_free(result);
     return from;
 }
@@ -5580,9 +5590,9 @@ find_term_bykeys(char_u *src)
 
     for (i = 0; i < tc_len; ++i)
     {
-	if (slen == termcodes[i].len
-			&& STRNCMP(termcodes[i].code, src, (size_t)slen) == 0)
-	    return i;
+        if (slen == termcodes[i].len
+                && STRNCMP(termcodes[i].code, src, (size_t)slen) == 0)
+            return i;
     }
     return -1;
 }
@@ -5599,21 +5609,21 @@ gather_termleader(void)
 
 #ifdef FEAT_GUI
     if (gui.in_use)
-	termleader[len++] = CSI;    /* the GUI codes are not in termcodes[] */
+        termleader[len++] = CSI;    /* the GUI codes are not in termcodes[] */
 #endif
 #ifdef FEAT_TERMRESPONSE
     if (check_for_codes)
-	termleader[len++] = DCS;    /* the termcode response starts with DCS
-				       in 8-bit mode */
+        termleader[len++] = DCS;    /* the termcode response starts with DCS
+                                       in 8-bit mode */
 #endif
     termleader[len] = NUL;
 
     for (i = 0; i < tc_len; ++i)
-	if (vim_strchr(termleader, termcodes[i].code[0]) == NULL)
-	{
-	    termleader[len++] = termcodes[i].code[0];
-	    termleader[len] = NUL;
-	}
+        if (vim_strchr(termleader, termcodes[i].code[0]) == NULL)
+        {
+            termleader[len++] = termcodes[i].code[0];
+            termleader[len] = NUL;
+        }
 
     need_gather = FALSE;
 }
@@ -5639,10 +5649,10 @@ show_termcodes(void)
 #define GAP 2	    /* spaces between columns */
 
     if (tc_len == 0)	    /* no terminal codes (must be GUI) */
-	return;
+        return;
     items = (int *)alloc((unsigned)(sizeof(int) * tc_len));
     if (items == NULL)
-	return;
+        return;
 
     /* Highlight title */
     MSG_PUTS_TITLE(_("\n--- Terminal keys ---"));
@@ -5655,51 +5665,51 @@ show_termcodes(void)
      */
     for (run = 1; run <= 3 && !got_int; ++run)
     {
-	/*
-	 * collect the items in items[]
-	 */
-	item_count = 0;
-	for (i = 0; i < tc_len; i++)
-	{
-	    len = show_one_termcode(termcodes[i].name,
-						    termcodes[i].code, FALSE);
-	    if (len <= INC3 - GAP ? run == 1
-			: len <= INC2 - GAP ? run == 2
-			: run == 3)
-		items[item_count++] = i;
-	}
-
-	/*
-	 * display the items
-	 */
-	if (run <= 2)
-	{
-	    cols = (Columns + GAP) / (run == 1 ? INC3 : INC2);
-	    if (cols == 0)
-		cols = 1;
-	    rows = (item_count + cols - 1) / cols;
-	}
-	else	/* run == 3 */
-	    rows = item_count;
-	for (row = 0; row < rows && !got_int; ++row)
-	{
-	    msg_putchar('\n');			/* go to next line */
-	    if (got_int)			/* 'q' typed in more */
-		break;
-	    col = 0;
-	    for (i = row; i < item_count; i += rows)
-	    {
-		msg_col = col;			/* make columns */
-		show_one_termcode(termcodes[items[i]].name,
-					      termcodes[items[i]].code, TRUE);
-		if (run == 2)
-		    col += INC2;
-		else
-		    col += INC3;
-	    }
-	    out_flush();
-	    ui_breakcheck();
-	}
+        /*
+         * collect the items in items[]
+         */
+        item_count = 0;
+        for (i = 0; i < tc_len; i++)
+        {
+            len = show_one_termcode(termcodes[i].name,
+                    termcodes[i].code, FALSE);
+            if (len <= INC3 - GAP ? run == 1
+                    : len <= INC2 - GAP ? run == 2
+                    : run == 3)
+                items[item_count++] = i;
+        }
+
+        /*
+         * display the items
+         */
+        if (run <= 2)
+        {
+            cols = (Columns + GAP) / (run == 1 ? INC3 : INC2);
+            if (cols == 0)
+                cols = 1;
+            rows = (item_count + cols - 1) / cols;
+        }
+        else	/* run == 3 */
+            rows = item_count;
+        for (row = 0; row < rows && !got_int; ++row)
+        {
+            msg_putchar('\n');			/* go to next line */
+            if (got_int)			/* 'q' typed in more */
+                break;
+            col = 0;
+            for (i = row; i < item_count; i += rows)
+            {
+                msg_col = col;			/* make columns */
+                show_one_termcode(termcodes[items[i]].name,
+                        termcodes[items[i]].code, TRUE);
+                if (run == 2)
+                    col += INC2;
+                else
+                    col += INC3;
+            }
+            out_flush();
+            ui_breakcheck();
+        }
     }
     vim_free(items);
 }
@@ -5716,42 +5726,42 @@ show_one_termcode(char_u *name, char_u *code, int printit)
 
     if (name[0] > '~')
     {
-	IObuff[0] = ' ';
-	IObuff[1] = ' ';
-	IObuff[2] = ' ';
-	IObuff[3] = ' ';
+        IObuff[0] = ' ';
+        IObuff[1] = ' ';
+        IObuff[2] = ' ';
+        IObuff[3] = ' ';
     }
     else
     {
-	IObuff[0] = 't';
-	IObuff[1] = '_';
-	IObuff[2] = name[0];
-	IObuff[3] = name[1];
+        IObuff[0] = 't';
+        IObuff[1] = '_';
+        IObuff[2] = name[0];
+        IObuff[3] = name[1];
     }
     IObuff[4] = ' ';
 
     p = get_special_key_name(TERMCAP2KEY(name[0], name[1]), 0);
     if (p[1] != 't')
-	STRCPY(IObuff + 5, p);
+        STRCPY(IObuff + 5, p);
     else
-	IObuff[5] = NUL;
+        IObuff[5] = NUL;
     len = (int)STRLEN(IObuff);
     do
-	IObuff[len++] = ' ';
+        IObuff[len++] = ' ';
     while (len < 17);
     IObuff[len] = NUL;
     if (code == NULL)
-	len += 4;
+        len += 4;
     else
-	len += vim_strsize(code);
+        len += vim_strsize(code);
 
     if (printit)
     {
-	msg_puts(IObuff);
-	if (code == NULL)
-	    msg_puts((char_u *)"NULL");
-	else
-	    msg_outtrans(code);
+        msg_puts(IObuff);
+        if (code == NULL)
+            msg_puts((char_u *)"NULL");
+        else
+            msg_outtrans(code);
     }
     return len;
 }
@@ -5781,28 +5791,28 @@ req_more_codes_from_term(void)
 
     /* Don't do anything when going to exit. */
     if (exiting)
-	return;
+        return;
 
     /* Send up to 10 more requests out than we received.  Avoid sending too
      * many, there can be a buffer overflow somewhere. */
     while (xt_index_out < xt_index_in + 10 && key_names[xt_index_out] != NULL)
     {
 # ifdef DEBUG_TERMRESPONSE
-	char dbuf[100];
+        char dbuf[100];
 
-	sprintf(dbuf, "Requesting XT %d: %s",
-				       xt_index_out, key_names[xt_index_out]);
-	log_tr(dbuf);
+        sprintf(dbuf, "Requesting XT %d: %s",
+                xt_index_out, key_names[xt_index_out]);
+        log_tr(dbuf);
 # endif
-	sprintf(buf, "\033P+q%02x%02x\033\\",
-		      key_names[xt_index_out][0], key_names[xt_index_out][1]);
-	out_str_nf((char_u *)buf);
-	++xt_index_out;
+        sprintf(buf, "\033P+q%02x%02x\033\\",
+                key_names[xt_index_out][0], key_names[xt_index_out][1]);
+        out_str_nf((char_u *)buf);
+        ++xt_index_out;
     }
 
     /* Send the codes out right away. */
     if (xt_index_out != old_idx)
-	out_flush();
+        out_flush();
 }
 
 /*
@@ -5826,66 +5836,66 @@ got_code_from_term(char_u *code, int len)
      * Our names are currently all 2 characters. */
     if (code[0] == '1' && code[7] == '=' && len / 2 < XT_LEN)
     {
-	/* Get the name from the response and find it in the table. */
-	name[0] = hexhex2nr(code + 3);
-	name[1] = hexhex2nr(code + 5);
-	name[2] = NUL;
-	for (i = 0; key_names[i] != NULL; ++i)
-	{
-	    if (STRCMP(key_names[i], name) == 0)
-	    {
-		xt_index_in = i;
-		break;
-	    }
-	}
+        /* Get the name from the response and find it in the table. */
+        name[0] = hexhex2nr(code + 3);
+        name[1] = hexhex2nr(code + 5);
+        name[2] = NUL;
+        for (i = 0; key_names[i] != NULL; ++i)
+        {
+            if (STRCMP(key_names[i], name) == 0)
+            {
+                xt_index_in = i;
+                break;
+            }
+        }
 # ifdef DEBUG_TERMRESPONSE
-	{
-	    char buf[100];
+        {
+            char buf[100];
 
-	    sprintf(buf, "Received XT %d: %s", xt_index_in, (char *)name);
-	    log_tr(buf);
-	}
+            sprintf(buf, "Received XT %d: %s", xt_index_in, (char *)name);
+            log_tr(buf);
+        }
 # endif
-	if (key_names[i] != NULL)
-	{
-	    for (i = 8; (c = hexhex2nr(code + i)) >= 0; i += 2)
-		str[j++] = c;
-	    str[j] = NUL;
-	    if (name[0] == 'C' && name[1] == 'o')
-	    {
-		/* Color count is not a key code. */
-		i = atoi((char *)str);
-		if (i != t_colors)
-		{
-		    /* Nr of colors changed, initialize highlighting and
-		     * redraw everything.  This causes a redraw, which usually
-		     * clears the message.  Try keeping the message if it
-		     * might work. */
-		    set_keep_msg_from_hist();
-		    set_color_count(i);
-		    init_highlight(TRUE, FALSE);
+        if (key_names[i] != NULL)
+        {
+            for (i = 8; (c = hexhex2nr(code + i)) >= 0; i += 2)
+                str[j++] = c;
+            str[j] = NUL;
+            if (name[0] == 'C' && name[1] == 'o')
+            {
+                /* Color count is not a key code. */
+                i = atoi((char *)str);
+                if (i != t_colors)
+                {
+                    /* Nr of colors changed, initialize highlighting and
+                     * redraw everything.  This causes a redraw, which usually
+                     * clears the message.  Try keeping the message if it
+                     * might work. */
+                    set_keep_msg_from_hist();
+                    set_color_count(i);
+                    init_highlight(TRUE, FALSE);
 #ifdef DEBUG_TERMRESPONSE
-		    {
-			char buf[100];
-			int  r = redraw_asap(CLEAR);
+                    {
+                        char buf[100];
+                        int  r = redraw_asap(CLEAR);
 
-			sprintf(buf, "Received t_Co, redraw_asap(): %d", r);
-			log_tr(buf);
-		    }
+                        sprintf(buf, "Received t_Co, redraw_asap(): %d", r);
+                        log_tr(buf);
+                    }
 #else
-		    redraw_asap(CLEAR);
-#endif
-		}
-	    }
-	    else
-	    {
-		/* First delete any existing entry with the same code. */
-		i = find_term_bykeys(str);
-		if (i >= 0)
-		    del_termcode_idx(i);
-		add_termcode(name, str, ATC_FROM_TERM);
-	    }
-	}
+                    redraw_asap(CLEAR);
+#endif
+                }
+            }
+            else
+            {
+                /* First delete any existing entry with the same code. */
+                i = find_term_bykeys(str);
+                if (i >= 0)
+                    del_termcode_idx(i);
+                add_termcode(name, str, ATC_FROM_TERM);
+            }
+        }
     }
 
     /* May request more codes now that we received one. */
@@ -5906,7 +5916,7 @@ check_for_codes_from_term(void)
 
     /* If no codes requested or all are answered, no need to wait. */
     if (xt_index_out == 0 || xt_index_out == xt_index_in)
-	return;
+        return;
 
     /* Vgetc() will check for and handle any response.
      * Keep calling vpeekc() until we don't get any responses. */
@@ -5914,22 +5924,22 @@ check_for_codes_from_term(void)
     ++allow_keys;
     for (;;)
     {
-	c = vpeekc();
-	if (c == NUL)	    /* nothing available */
-	    break;
-
-	/* If a response is recognized it's replaced with K_IGNORE, must read
-	 * it from the input stream.  If there is no K_IGNORE we can't do
-	 * anything, break here (there might be some responses further on, but
-	 * we don't want to throw away any typed chars). */
-	if (c != K_SPECIAL && c != K_IGNORE)
-	    break;
-	c = vgetc();
-	if (c != K_IGNORE)
-	{
-	    vungetc(c);
-	    break;
-	}
+        c = vpeekc();
+        if (c == NUL)	    /* nothing available */
+            break;
+
+        /* If a response is recognized it's replaced with K_IGNORE, must read
+         * it from the input stream.  If there is no K_IGNORE we can't do
+         * anything, break here (there might be some responses further on, but
+         * we don't want to throw away any typed chars). */
+        if (c != K_SPECIAL && c != K_IGNORE)
+            break;
+        c = vgetc();
+        if (c != K_IGNORE)
+        {
+            vungetc(c);
+            break;
+        }
     }
     --no_mapping;
     --allow_keys;
@@ -5951,10 +5961,10 @@ check_for_codes_from_term(void)
  *
  * Returns NULL when there is a problem.
  */
-    char_u *
+char_u *
 translate_mapping(
-    char_u	*str,
-    int		expmap)  /* TRUE when expanding mappings on command-line */
+        char_u	*str,
+        int		expmap)  /* TRUE when expanding mappings on command-line */
 {
     garray_T	ga;
     int		c;
@@ -5973,60 +5983,60 @@ translate_mapping(
 
     for (; *str; ++str)
     {
-	c = *str;
-	if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)
-	{
-	    modifiers = 0;
-	    if (str[1] == KS_MODIFIER)
-	    {
-		str++;
-		modifiers = *++str;
-		c = *++str;
-	    }
-	    if (cpo_special && cpo_keycode && c == K_SPECIAL && !modifiers)
-	    {
-		int	i;
-
-		/* try to find special key in termcodes */
-		for (i = 0; i < tc_len; ++i)
-		    if (termcodes[i].name[0] == str[1]
-					    && termcodes[i].name[1] == str[2])
-			break;
-		if (i < tc_len)
-		{
-		    ga_concat(&ga, termcodes[i].code);
-		    str += 2;
-		    continue; /* for (str) */
-		}
-	    }
-	    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)
-	    {
-		if (expmap && cpo_special)
-		{
-		    ga_clear(&ga);
-		    return NULL;
-		}
-		c = TO_SPECIAL(str[1], str[2]);
-		if (c == K_ZERO)	/* display <Nul> as ^@ */
-		    c = NUL;
-		str += 2;
-	    }
-	    if (IS_SPECIAL(c) || modifiers)	/* special key */
-	    {
-		if (expmap && cpo_special)
-		{
-		    ga_clear(&ga);
-		    return NULL;
-		}
-		ga_concat(&ga, get_special_key_name(c, modifiers));
-		continue; /* for (str) */
-	    }
-	}
-	if (c == ' ' || c == '\t' || c == Ctrl_J || c == Ctrl_V
-	    || (c == '<' && !cpo_special) || (c == '\\' && !cpo_bslash))
-	    ga_append(&ga, cpo_bslash ? Ctrl_V : '\\');
-	if (c)
-	    ga_append(&ga, c);
+        c = *str;
+        if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)
+        {
+            modifiers = 0;
+            if (str[1] == KS_MODIFIER)
+            {
+                str++;
+                modifiers = *++str;
+                c = *++str;
+            }
+            if (cpo_special && cpo_keycode && c == K_SPECIAL && !modifiers)
+            {
+                int	i;
+
+                /* try to find special key in termcodes */
+                for (i = 0; i < tc_len; ++i)
+                    if (termcodes[i].name[0] == str[1]
+                            && termcodes[i].name[1] == str[2])
+                        break;
+                if (i < tc_len)
+                {
+                    ga_concat(&ga, termcodes[i].code);
+                    str += 2;
+                    continue; /* for (str) */
+                }
+            }
+            if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)
+            {
+                if (expmap && cpo_special)
+                {
+                    ga_clear(&ga);
+                    return NULL;
+                }
+                c = TO_SPECIAL(str[1], str[2]);
+                if (c == K_ZERO)	/* display <Nul> as ^@ */
+                    c = NUL;
+                str += 2;
+            }
+            if (IS_SPECIAL(c) || modifiers)	/* special key */
+            {
+                if (expmap && cpo_special)
+                {
+                    ga_clear(&ga);
+                    return NULL;
+                }
+                ga_concat(&ga, get_special_key_name(c, modifiers));
+                continue; /* for (str) */
+            }
+        }
+        if (c == ' ' || c == '\t' || c == Ctrl_J || c == Ctrl_V
+                || (c == '<' && !cpo_special) || (c == '\\' && !cpo_bslash))
+            ga_append(&ga, cpo_bslash ? Ctrl_V : '\\');
+        if (c)
+            ga_append(&ga, c);
     }
     ga_append(&ga, NUL);
     return (char_u *)(ga.ga_data);
@@ -6049,19 +6059,19 @@ update_tcap(int attr)
     p = find_builtin_term(DEFAULT_TERM);
     sprintf(ksme_str, IF_EB("\033|%dm", ESC_STR "|%dm"), attr);
     sprintf(ksmd_str, IF_EB("\033|%dm", ESC_STR "|%dm"),
-				     attr | 0x08);  /* FOREGROUND_INTENSITY */
+            attr | 0x08);  /* FOREGROUND_INTENSITY */
     sprintf(ksmr_str, IF_EB("\033|%dm", ESC_STR "|%dm"),
-				 ((attr & 0x0F) << 4) | ((attr & 0xF0) >> 4));
+            ((attr & 0x0F) << 4) | ((attr & 0xF0) >> 4));
 
     while (p->bt_string != NULL)
     {
-      if (p->bt_entry == (int)KS_ME)
-	  p->bt_string = &ksme_str[0];
-      else if (p->bt_entry == (int)KS_MR)
-	  p->bt_string = &ksmr_str[0];
-      else if (p->bt_entry == (int)KS_MD)
-	  p->bt_string = &ksmd_str[0];
-      ++p;
+        if (p->bt_entry == (int)KS_ME)
+            p->bt_string = &ksme_str[0];
+        else if (p->bt_entry == (int)KS_MR)
+            p->bt_string = &ksmr_str[0];
+        else if (p->bt_entry == (int)KS_MD)
+            p->bt_string = &ksmd_str[0];
+        ++p;
     }
 }
 #endif
@@ -6071,10 +6081,10 @@ update_tcap(int attr)
 hex_digit(int c)
 {
     if (isdigit(c))
-	return c - '0';
+        return c - '0';
     c = TOLOWER_ASC(c);
     if (c >= 'a' && c <= 'f')
-	return c - 'a' + 10;
+        return c - 'a' + 10;
     return 0x1ffffff;
 }
 
@@ -6094,79 +6104,79 @@ gui_get_color_cmn(char_u *name)
     guicolor_T  color;
 
     struct rgbcolor_table_S {
-	char_u	    *color_name;
-	guicolor_T  color;
+        char_u	    *color_name;
+        guicolor_T  color;
     };
 
     static struct rgbcolor_table_S rgb_table[] = {
-	    {(char_u *)"black",		RGB(0x00, 0x00, 0x00)},
-	    {(char_u *)"blue",		RGB(0x00, 0x00, 0xFF)},
-	    {(char_u *)"brown",		RGB(0xA5, 0x2A, 0x2A)},
-	    {(char_u *)"cyan",		RGB(0x00, 0xFF, 0xFF)},
-	    {(char_u *)"darkblue",	RGB(0x00, 0x00, 0x8B)},
-	    {(char_u *)"darkcyan",	RGB(0x00, 0x8B, 0x8B)},
-	    {(char_u *)"darkgray",	RGB(0xA9, 0xA9, 0xA9)},
-	    {(char_u *)"darkgreen",	RGB(0x00, 0x64, 0x00)},
-	    {(char_u *)"darkgrey",	RGB(0xA9, 0xA9, 0xA9)},
-	    {(char_u *)"darkmagenta",	RGB(0x8B, 0x00, 0x8B)},
-	    {(char_u *)"darkred",	RGB(0x8B, 0x00, 0x00)},
-	    {(char_u *)"darkyellow",	RGB(0x8B, 0x8B, 0x00)}, /* No X11 */
-	    {(char_u *)"gray",		RGB(0xBE, 0xBE, 0xBE)},
-	    {(char_u *)"gray10",	RGB(0x1A, 0x1A, 0x1A)},
-	    {(char_u *)"gray20",	RGB(0x33, 0x33, 0x33)},
-	    {(char_u *)"gray30",	RGB(0x4D, 0x4D, 0x4D)},
-	    {(char_u *)"gray40",	RGB(0x66, 0x66, 0x66)},
-	    {(char_u *)"gray50",	RGB(0x7F, 0x7F, 0x7F)},
-	    {(char_u *)"gray60",	RGB(0x99, 0x99, 0x99)},
-	    {(char_u *)"gray70",	RGB(0xB3, 0xB3, 0xB3)},
-	    {(char_u *)"gray80",	RGB(0xCC, 0xCC, 0xCC)},
-	    {(char_u *)"gray90",	RGB(0xE5, 0xE5, 0xE5)},
-	    {(char_u *)"green",		RGB(0x00, 0xFF, 0x00)},
-	    {(char_u *)"grey",		RGB(0xBE, 0xBE, 0xBE)},
-	    {(char_u *)"grey10",	RGB(0x1A, 0x1A, 0x1A)},
-	    {(char_u *)"grey20",	RGB(0x33, 0x33, 0x33)},
-	    {(char_u *)"grey30",	RGB(0x4D, 0x4D, 0x4D)},
-	    {(char_u *)"grey40",	RGB(0x66, 0x66, 0x66)},
-	    {(char_u *)"grey50",	RGB(0x7F, 0x7F, 0x7F)},
-	    {(char_u *)"grey60",	RGB(0x99, 0x99, 0x99)},
-	    {(char_u *)"grey70",	RGB(0xB3, 0xB3, 0xB3)},
-	    {(char_u *)"grey80",	RGB(0xCC, 0xCC, 0xCC)},
-	    {(char_u *)"grey90",	RGB(0xE5, 0xE5, 0xE5)},
-	    {(char_u *)"lightblue",	RGB(0xAD, 0xD8, 0xE6)},
-	    {(char_u *)"lightcyan",	RGB(0xE0, 0xFF, 0xFF)},
-	    {(char_u *)"lightgray",	RGB(0xD3, 0xD3, 0xD3)},
-	    {(char_u *)"lightgreen",	RGB(0x90, 0xEE, 0x90)},
-	    {(char_u *)"lightgrey",	RGB(0xD3, 0xD3, 0xD3)},
-	    {(char_u *)"lightmagenta",	RGB(0xFF, 0x8B, 0xFF)}, /* No X11 */
-	    {(char_u *)"lightred",	RGB(0xFF, 0x8B, 0x8B)}, /* No X11 */
-	    {(char_u *)"lightyellow",	RGB(0xFF, 0xFF, 0xE0)},
-	    {(char_u *)"magenta",	RGB(0xFF, 0x00, 0xFF)},
-	    {(char_u *)"orange",	RGB(0xFF, 0xA5, 0x00)},
-	    {(char_u *)"purple",	RGB(0xA0, 0x20, 0xF0)},
-	    {(char_u *)"red",		RGB(0xFF, 0x00, 0x00)},
-	    {(char_u *)"seagreen",	RGB(0x2E, 0x8B, 0x57)},
-	    {(char_u *)"slateblue",	RGB(0x6A, 0x5A, 0xCD)},
-	    {(char_u *)"violet",	RGB(0xEE, 0x82, 0xEE)},
-	    {(char_u *)"white",		RGB(0xFF, 0xFF, 0xFF)},
-	    {(char_u *)"yellow",	RGB(0xFF, 0xFF, 0x00)},
+        {(char_u *)"black",		RGB(0x00, 0x00, 0x00)},
+        {(char_u *)"blue",		RGB(0x00, 0x00, 0xFF)},
+        {(char_u *)"brown",		RGB(0xA5, 0x2A, 0x2A)},
+        {(char_u *)"cyan",		RGB(0x00, 0xFF, 0xFF)},
+        {(char_u *)"darkblue",	RGB(0x00, 0x00, 0x8B)},
+        {(char_u *)"darkcyan",	RGB(0x00, 0x8B, 0x8B)},
+        {(char_u *)"darkgray",	RGB(0xA9, 0xA9, 0xA9)},
+        {(char_u *)"darkgreen",	RGB(0x00, 0x64, 0x00)},
+        {(char_u *)"darkgrey",	RGB(0xA9, 0xA9, 0xA9)},
+        {(char_u *)"darkmagenta",	RGB(0x8B, 0x00, 0x8B)},
+        {(char_u *)"darkred",	RGB(0x8B, 0x00, 0x00)},
+        {(char_u *)"darkyellow",	RGB(0x8B, 0x8B, 0x00)}, /* No X11 */
+        {(char_u *)"gray",		RGB(0xBE, 0xBE, 0xBE)},
+        {(char_u *)"gray10",	RGB(0x1A, 0x1A, 0x1A)},
+        {(char_u *)"gray20",	RGB(0x33, 0x33, 0x33)},
+        {(char_u *)"gray30",	RGB(0x4D, 0x4D, 0x4D)},
+        {(char_u *)"gray40",	RGB(0x66, 0x66, 0x66)},
+        {(char_u *)"gray50",	RGB(0x7F, 0x7F, 0x7F)},
+        {(char_u *)"gray60",	RGB(0x99, 0x99, 0x99)},
+        {(char_u *)"gray70",	RGB(0xB3, 0xB3, 0xB3)},
+        {(char_u *)"gray80",	RGB(0xCC, 0xCC, 0xCC)},
+        {(char_u *)"gray90",	RGB(0xE5, 0xE5, 0xE5)},
+        {(char_u *)"green",		RGB(0x00, 0xFF, 0x00)},
+        {(char_u *)"grey",		RGB(0xBE, 0xBE, 0xBE)},
+        {(char_u *)"grey10",	RGB(0x1A, 0x1A, 0x1A)},
+        {(char_u *)"grey20",	RGB(0x33, 0x33, 0x33)},
+        {(char_u *)"grey30",	RGB(0x4D, 0x4D, 0x4D)},
+        {(char_u *)"grey40",	RGB(0x66, 0x66, 0x66)},
+        {(char_u *)"grey50",	RGB(0x7F, 0x7F, 0x7F)},
+        {(char_u *)"grey60",	RGB(0x99, 0x99, 0x99)},
+        {(char_u *)"grey70",	RGB(0xB3, 0xB3, 0xB3)},
+        {(char_u *)"grey80",	RGB(0xCC, 0xCC, 0xCC)},
+        {(char_u *)"grey90",	RGB(0xE5, 0xE5, 0xE5)},
+        {(char_u *)"lightblue",	RGB(0xAD, 0xD8, 0xE6)},
+        {(char_u *)"lightcyan",	RGB(0xE0, 0xFF, 0xFF)},
+        {(char_u *)"lightgray",	RGB(0xD3, 0xD3, 0xD3)},
+        {(char_u *)"lightgreen",	RGB(0x90, 0xEE, 0x90)},
+        {(char_u *)"lightgrey",	RGB(0xD3, 0xD3, 0xD3)},
+        {(char_u *)"lightmagenta",	RGB(0xFF, 0x8B, 0xFF)}, /* No X11 */
+        {(char_u *)"lightred",	RGB(0xFF, 0x8B, 0x8B)}, /* No X11 */
+        {(char_u *)"lightyellow",	RGB(0xFF, 0xFF, 0xE0)},
+        {(char_u *)"magenta",	RGB(0xFF, 0x00, 0xFF)},
+        {(char_u *)"orange",	RGB(0xFF, 0xA5, 0x00)},
+        {(char_u *)"purple",	RGB(0xA0, 0x20, 0xF0)},
+        {(char_u *)"red",		RGB(0xFF, 0x00, 0x00)},
+        {(char_u *)"seagreen",	RGB(0x2E, 0x8B, 0x57)},
+        {(char_u *)"slateblue",	RGB(0x6A, 0x5A, 0xCD)},
+        {(char_u *)"violet",	RGB(0xEE, 0x82, 0xEE)},
+        {(char_u *)"white",		RGB(0xFF, 0xFF, 0xFF)},
+        {(char_u *)"yellow",	RGB(0xFF, 0xFF, 0x00)},
     };
 
 
     if (name[0] == '#' && STRLEN(name) == 7)
     {
-	/* Name is in "#rrggbb" format */
-	color = RGB(((hex_digit(name[1]) << 4) + hex_digit(name[2])),
-		    ((hex_digit(name[3]) << 4) + hex_digit(name[4])),
-		    ((hex_digit(name[5]) << 4) + hex_digit(name[6])));
-	if (color > 0xffffff)
-	    return INVALCOLOR;
-	return color;
+        /* Name is in "#rrggbb" format */
+        color = RGB(((hex_digit(name[1]) << 4) + hex_digit(name[2])),
+                ((hex_digit(name[3]) << 4) + hex_digit(name[4])),
+                ((hex_digit(name[5]) << 4) + hex_digit(name[6])));
+        if (color > 0xffffff)
+            return INVALCOLOR;
+        return color;
     }
 
     /* Check if the name is one of the colors we know */
     for (i = 0; i < (int)(sizeof(rgb_table) / sizeof(rgb_table[0])); i++)
-	if (STRICMP(name, rgb_table[i].color_name) == 0)
-	    return rgb_table[i].color;
+        if (STRICMP(name, rgb_table[i].color_name) == 0)
+            return rgb_table[i].color;
 
     /*
      * Last attempt. Look in the file "$VIM/rgb.txt".
@@ -6174,39 +6184,39 @@ gui_get_color_cmn(char_u *name)
 
     fname = expand_env_save((char_u *)"$VIMRUNTIME/rgb.txt");
     if (fname == NULL)
-	return INVALCOLOR;
+        return INVALCOLOR;
 
     fd = fopen((char *)fname, "rt");
     vim_free(fname);
     if (fd == NULL)
     {
-	if (p_verbose > 1)
-	    verb_msg((char_u *)_("Cannot open $VIMRUNTIME/rgb.txt"));
-	return INVALCOLOR;
+        if (p_verbose > 1)
+            verb_msg((char_u *)_("Cannot open $VIMRUNTIME/rgb.txt"));
+        return INVALCOLOR;
     }
 
     while (!feof(fd))
     {
-	size_t		len;
-	int		pos;
+        size_t		len;
+        int		pos;
 
-	ignoredp = fgets(line, LINE_LEN, fd);
-	len = strlen(line);
+        ignoredp = fgets(line, LINE_LEN, fd);
+        len = strlen(line);
 
-	if (len <= 1 || line[len - 1] != '\n')
-	    continue;
+        if (len <= 1 || line[len - 1] != '\n')
+            continue;
 
-	line[len - 1] = '\0';
+        line[len - 1] = '\0';
 
-	i = sscanf(line, "%d %d %d %n", &r, &g, &b, &pos);
-	if (i != 3)
-	    continue;
+        i = sscanf(line, "%d %d %d %n", &r, &g, &b, &pos);
+        if (i != 3)
+            continue;
 
-	if (STRICMP(line + pos, name) == 0)
-	{
-	    fclose(fd);
-	    return (guicolor_T)RGB(r, g, b);
-	}
+        if (STRICMP(line + pos, name) == 0)
+        {
+            fclose(fd);
+            return (guicolor_T)RGB(r, g, b);
+        }
     }
     fclose(fd);
     return INVALCOLOR;
